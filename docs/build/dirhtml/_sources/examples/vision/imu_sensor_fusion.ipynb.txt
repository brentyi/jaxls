{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "cell-0",
   "metadata": {},
   "source": "# IMU fusion + calibration\n\nFusing IMU measurements with sparse position fixes to estimate poses, velocities, and sensor biases.\n\n**Inputs:** High-rate accelerometer/gyroscope data, occasional GPS-like position priors  \n**Outputs:** Trajectory (poses + velocities) and calibrated IMU biases\n\nFeatures used:\n- {class}`~jaxls.SE3Var` for 6-DOF poses\n- {class}`~jaxls.Var` subclassing for velocity and IMU bias variables\n- {func}`@jaxls.Cost.factory <jaxls.Cost.factory>` for preintegration costs\n- Batched construction for efficient problem building"
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-1",
   "metadata": {
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "import sys\n",
    "from loguru import logger\n",
    "\n",
    "logger.remove()\n",
    "logger.add(sys.stdout, format=\"<level>{level: <8}</level> | {message}\");"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-2",
   "metadata": {},
   "outputs": [],
   "source": [
    "import jax\n",
    "import jax.numpy as jnp\n",
    "import jaxlie\n",
    "import jaxls\n",
    "import numpy as np"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-3",
   "metadata": {},
   "source": "## Custom variables\n\nIn addition to SE3 poses, we need:\n- Velocity: 3D linear velocity in world frame\n- IMU Bias: 6D vector (3 accelerometer + 3 gyroscope biases)"
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-4",
   "metadata": {},
   "outputs": [],
   "source": [
    "class VelocityVar(jaxls.Var[jax.Array], default_factory=lambda: jnp.zeros(3)):\n",
    "    \"\"\"3D velocity in world frame.\"\"\"\n",
    "\n",
    "\n",
    "class BiasVar(jaxls.Var[jax.Array], default_factory=lambda: jnp.zeros(6)):\n",
    "    \"\"\"IMU bias: [accel_bias (3), gyro_bias (3)].\"\"\""
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-5",
   "metadata": {},
   "source": [
    "## Generate synthetic IMU data\n",
    "\n",
    "We simulate a vehicle moving in a circular trajectory. The ground truth trajectory gives us:\n",
    "- True poses, velocities at each keyframe\n",
    "- Synthetic IMU measurements (with noise and bias) between keyframes"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-6",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Simulation parameters\n",
    "n_keyframes = 40\n",
    "imu_rate = 100  # Hz\n",
    "keyframe_dt = 0.5  # seconds between keyframes\n",
    "imu_measurements_per_keyframe = int(imu_rate * keyframe_dt)\n",
    "imu_dt = keyframe_dt / imu_measurements_per_keyframe\n",
    "\n",
    "# True IMU biases (constant) - larger values for clear demonstration\n",
    "true_accel_bias = jnp.array([0.3, -0.2, 0.15])  # m/s^2\n",
    "true_gyro_bias = jnp.array([0.02, -0.01, 0.005])  # rad/s\n",
    "\n",
    "true_bias = jnp.concatenate([true_accel_bias, true_gyro_bias])\n",
    "\n",
    "# Gravity in world frame\n",
    "gravity = jnp.array([0.0, 0.0, -9.81])\n",
    "\n",
    "# Noise parameters (low to make bias estimation cleaner)\n",
    "accel_noise_std = 0.01\n",
    "gyro_noise_std = 0.001\n",
    "\n",
    "print(f\"Keyframes: {n_keyframes}\")\n",
    "print(f\"Total time: {n_keyframes * keyframe_dt:.1f}s\")\n",
    "print(f\"IMU measurements per interval: {imu_measurements_per_keyframe}\")\n",
    "print(f\"True biases: accel={true_accel_bias}, gyro={true_gyro_bias}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-7",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Helper for displaying orientation variation\n",
    "def so3_to_rpy(rot: jaxlie.SO3) -> jax.Array:\n",
    "    \"\"\"Extract roll, pitch, yaw from SO3.\"\"\"\n",
    "    R = rot.as_matrix()\n",
    "    pitch = jnp.arcsin(-R[2, 0])\n",
    "    roll = jnp.arctan2(R[2, 1], R[2, 2])\n",
    "    yaw = jnp.arctan2(R[1, 0], R[0, 0])\n",
    "    return jnp.array([roll, pitch, yaw])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-8",
   "metadata": {},
   "outputs": [],
   "source": [
    "def trajectory_state(\n",
    "    t: jax.Array,\n",
    "    scale: float = 5.0,\n",
    "    height_amplitude: float = 3.0,\n",
    "    base_height: float = 5.0,\n",
    "    period: float = 10.0,\n",
    ") -> tuple[jax.Array, jax.Array]:\n",
    "    \"\"\"Compute position and Euler angles at time t.\n",
    "\n",
    "    Returns (position, euler_angles) where euler_angles = [roll, pitch, yaw].\n",
    "    \"\"\"\n",
    "    theta = 2 * jnp.pi * t / period\n",
    "    dtheta = 2 * jnp.pi / period\n",
    "\n",
    "    # Position\n",
    "    x = scale * jnp.sin(theta)\n",
    "    y = scale * jnp.sin(theta) * jnp.cos(theta)\n",
    "    z = base_height + height_amplitude * jnp.sin(2 * theta)\n",
    "    position = jnp.array([x, y, z])\n",
    "\n",
    "    # Velocity (needed for yaw and pitch computation)\n",
    "    vx = scale * jnp.cos(theta) * dtheta\n",
    "    vy = scale * jnp.cos(2 * theta) * dtheta\n",
    "    vz = 2 * height_amplitude * jnp.cos(2 * theta) * dtheta\n",
    "\n",
    "    # Euler angles\n",
    "    roll = 0.5 * jnp.sin(2 * theta)\n",
    "    yaw = jnp.arctan2(vy, vx)\n",
    "    v_horiz = jnp.sqrt(vx**2 + vy**2)\n",
    "    pitch = jnp.arctan2(vz, v_horiz)\n",
    "    euler = jnp.array([roll, pitch, yaw])\n",
    "\n",
    "    return position, euler\n",
    "\n",
    "\n",
    "def generate_trajectory_at_times(\n",
    "    times: jax.Array,\n",
    "    scale: float = 5.0,\n",
    "    height_amplitude: float = 3.0,\n",
    "    base_height: float = 5.0,\n",
    "    period: float = 10.0,\n",
    ") -> tuple[jaxlie.SE3, jax.Array, jax.Array, jax.Array]:\n",
    "    \"\"\"Generate trajectory using autodiff for velocities/accelerations.\n",
    "\n",
    "    Returns poses, velocities, accelerations, and body-frame angular velocities.\n",
    "    \"\"\"\n",
    "\n",
    "    def state_at_t(t: jax.Array) -> tuple[jax.Array, jax.Array]:\n",
    "        return trajectory_state(t, scale, height_amplitude, base_height, period)\n",
    "\n",
    "    # Use autodiff to compute derivatives\n",
    "    def position_at_t(t: jax.Array) -> jax.Array:\n",
    "        return state_at_t(t)[0]\n",
    "\n",
    "    def euler_at_t(t: jax.Array) -> jax.Array:\n",
    "        return state_at_t(t)[1]\n",
    "\n",
    "    # Velocity = d(position)/dt, Acceleration = d²(position)/dt²\n",
    "    velocity_fn = jax.jacfwd(position_at_t)\n",
    "    accel_fn = jax.jacfwd(velocity_fn)\n",
    "\n",
    "    # Euler angle rates\n",
    "    euler_dot_fn = jax.jacfwd(euler_at_t)\n",
    "\n",
    "    def compute_state(\n",
    "        t: jax.Array,\n",
    "    ) -> tuple[jaxlie.SE3, jax.Array, jax.Array, jax.Array]:\n",
    "        position, euler = state_at_t(t)\n",
    "        velocity = velocity_fn(t)\n",
    "        acceleration = accel_fn(t)\n",
    "        euler_dot = euler_dot_fn(t)\n",
    "\n",
    "        roll, pitch, yaw = euler\n",
    "        roll_dot, pitch_dot, yaw_dot = euler_dot\n",
    "\n",
    "        # Body angular velocity from Euler angle rates (ZYX convention)\n",
    "        omega_x = roll_dot - yaw_dot * jnp.sin(pitch)\n",
    "        omega_y = pitch_dot * jnp.cos(roll) + yaw_dot * jnp.cos(pitch) * jnp.sin(roll)\n",
    "        omega_z = -pitch_dot * jnp.sin(roll) + yaw_dot * jnp.cos(pitch) * jnp.cos(roll)\n",
    "        omega_body = jnp.array([omega_x, omega_y, omega_z])\n",
    "\n",
    "        # Build pose from Euler angles\n",
    "        rot = (\n",
    "            jaxlie.SO3.from_z_radians(yaw)\n",
    "            @ jaxlie.SO3.from_y_radians(pitch)\n",
    "            @ jaxlie.SO3.from_x_radians(roll)\n",
    "        )\n",
    "        pose = jaxlie.SE3.from_rotation_and_translation(rot, position)\n",
    "\n",
    "        return pose, velocity, acceleration, omega_body\n",
    "\n",
    "    # Vectorize over all times\n",
    "    poses, velocities, accelerations, angular_velocities = jax.vmap(compute_state)(\n",
    "        times\n",
    "    )\n",
    "\n",
    "    return poses, velocities, accelerations, angular_velocities\n",
    "\n",
    "\n",
    "def generate_imu_measurements(\n",
    "    accel_bias: jax.Array,\n",
    "    gyro_bias: jax.Array,\n",
    "    key: jax.Array,\n",
    ") -> tuple[jax.Array, jax.Array]:\n",
    "    \"\"\"Generate smooth IMU measurements by sampling the analytic trajectory.\n",
    "\n",
    "    Args:\n",
    "        accel_bias: Accelerometer bias (3,)\n",
    "        gyro_bias: Gyroscope bias (3,)\n",
    "        key: JAX random key\n",
    "\n",
    "    Returns:\n",
    "        Tuple of (accel_measurements, gyro_measurements) each with shape\n",
    "        (n_keyframes-1, imu_measurements_per_keyframe, 3)\n",
    "    \"\"\"\n",
    "    n_intervals = n_keyframes - 1\n",
    "\n",
    "    # Generate times for all IMU samples (centered in each dt interval)\n",
    "    interval_starts = jnp.arange(n_intervals) * keyframe_dt\n",
    "    imu_offsets = (jnp.arange(imu_measurements_per_keyframe) + 0.5) * imu_dt\n",
    "    times_imu = (interval_starts[:, None] + imu_offsets[None, :]).flatten()\n",
    "\n",
    "    # Get trajectory at IMU times using autodiff\n",
    "    poses_imu, _, accelerations_imu, omega_body = generate_trajectory_at_times(\n",
    "        times_imu\n",
    "    )\n",
    "\n",
    "    # Accelerometer measures specific force: a_body = R^T @ (a_world - g)\n",
    "    rotations = poses_imu.rotation()\n",
    "    specific_force_world = accelerations_imu - gravity[None, :]\n",
    "    accel_body = jax.vmap(lambda R, a: R.inverse() @ a)(rotations, specific_force_world)\n",
    "\n",
    "    # Gyroscope measures angular velocity in body frame\n",
    "    gyro_body = omega_body\n",
    "\n",
    "    # Reshape to (n_intervals, imu_measurements_per_keyframe, 3)\n",
    "    accel_body = accel_body.reshape(n_intervals, imu_measurements_per_keyframe, 3)\n",
    "    gyro_body = gyro_body.reshape(n_intervals, imu_measurements_per_keyframe, 3)\n",
    "\n",
    "    # Add bias and noise\n",
    "    keys = jax.random.split(key, 2)\n",
    "    accel_noise = jax.random.normal(keys[0], accel_body.shape) * accel_noise_std\n",
    "    gyro_noise = jax.random.normal(keys[1], gyro_body.shape) * gyro_noise_std\n",
    "\n",
    "    accels = accel_body + accel_bias[None, None, :] + accel_noise\n",
    "    gyros = gyro_body + gyro_bias[None, None, :] + gyro_noise\n",
    "\n",
    "    return accels, gyros\n",
    "\n",
    "\n",
    "# Generate ground truth trajectory at keyframe times\n",
    "keyframe_times = jnp.arange(n_keyframes) * keyframe_dt\n",
    "true_poses, true_velocities, _, _ = generate_trajectory_at_times(keyframe_times)\n",
    "\n",
    "# Generate IMU measurements\n",
    "key = jax.random.PRNGKey(42)\n",
    "accel_measurements, gyro_measurements = generate_imu_measurements(\n",
    "    true_accel_bias, true_gyro_bias, key\n",
    ")\n",
    "\n",
    "print(f\"Generated {n_keyframes} keyframe poses\")\n",
    "print(f\"IMU measurements shape: {accel_measurements.shape}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "652ilapuoyy",
   "metadata": {},
   "source": "The generated IMU measurements include accelerometer (linear acceleration in body frame) and gyroscope (angular velocity) readings. Vertical dotted lines indicate keyframe boundaries where preintegration intervals begin/end:"
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1bq3v1xu82",
   "metadata": {
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "import plotly.graph_objects as go\n",
    "from plotly.subplots import make_subplots\n",
    "from IPython.display import HTML\n",
    "\n",
    "# Visualize raw IMU measurements\n",
    "# Create time array for IMU measurements (vectorized)\n",
    "interval_starts = jnp.arange(n_keyframes - 1) * keyframe_dt\n",
    "imu_offsets = jnp.arange(imu_measurements_per_keyframe) * imu_dt\n",
    "times_imu = (interval_starts[:, None] + imu_offsets[None, :]).flatten()\n",
    "\n",
    "accel_flat = accel_measurements.reshape(-1, 3)\n",
    "gyro_flat = gyro_measurements.reshape(-1, 3)\n",
    "\n",
    "fig_imu = make_subplots(\n",
    "    rows=2,\n",
    "    cols=1,\n",
    "    subplot_titles=(\"Accelerometer Measurements\", \"Gyroscope Measurements\"),\n",
    "    vertical_spacing=0.12,\n",
    ")\n",
    "\n",
    "# Accelerometer\n",
    "colors = [\"steelblue\", \"coral\", \"forestgreen\"]\n",
    "labels = [\"x\", \"y\", \"z\"]\n",
    "for i, (color, label) in enumerate(zip(colors, labels)):\n",
    "    fig_imu.add_trace(\n",
    "        go.Scatter(\n",
    "            x=np.array(times_imu),\n",
    "            y=np.array(accel_flat[:, i]),\n",
    "            mode=\"lines\",\n",
    "            line=dict(color=color, width=1),\n",
    "            name=f\"accel_{label}\",\n",
    "            showlegend=True,\n",
    "        ),\n",
    "        row=1,\n",
    "        col=1,\n",
    "    )\n",
    "\n",
    "# Gyroscope\n",
    "for i, (color, label) in enumerate(zip(colors, labels)):\n",
    "    fig_imu.add_trace(\n",
    "        go.Scatter(\n",
    "            x=np.array(times_imu),\n",
    "            y=np.array(gyro_flat[:, i]),\n",
    "            mode=\"lines\",\n",
    "            line=dict(color=color, width=1),\n",
    "            name=f\"gyro_{label}\",\n",
    "            showlegend=True,\n",
    "        ),\n",
    "        row=2,\n",
    "        col=1,\n",
    "    )\n",
    "\n",
    "# Add keyframe markers\n",
    "keyframe_times = np.arange(n_keyframes) * keyframe_dt\n",
    "for t in keyframe_times:\n",
    "    fig_imu.add_vline(\n",
    "        x=t, line_dash=\"dot\", line_color=\"gray\", opacity=0.3, row=1, col=1\n",
    "    )\n",
    "    fig_imu.add_vline(\n",
    "        x=t, line_dash=\"dot\", line_color=\"gray\", opacity=0.3, row=2, col=1\n",
    "    )\n",
    "\n",
    "fig_imu.update_xaxes(title_text=\"Time (s)\", row=2, col=1)\n",
    "fig_imu.update_yaxes(title_text=\"Acceleration (m/s²)\", row=1, col=1)\n",
    "fig_imu.update_yaxes(title_text=\"Angular velocity (rad/s)\", row=2, col=1)\n",
    "\n",
    "fig_imu.update_layout(\n",
    "    height=400,\n",
    "    margin=dict(t=40, b=40, l=60, r=40),\n",
    "    legend=dict(orientation=\"h\", yanchor=\"bottom\", y=1.02, xanchor=\"center\", x=0.5),\n",
    ")\n",
    "\n",
    "HTML(fig_imu.to_html(full_html=False, include_plotlyjs=\"cdn\"))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-9",
   "metadata": {},
   "source": [
    "## IMU Preintegration\n",
    "\n",
    "Preintegration combines many high-frequency IMU measurements into a single relative motion constraint. Given IMU measurements between times $i$ and $j$, we compute:\n",
    "\n",
    "- $\\Delta R_{ij}$: Relative rotation\n",
    "- $\\Delta v_{ij}$: Velocity change (in frame $i$)\n",
    "- $\\Delta p_{ij}$: Position change (in frame $i$)\n",
    "\n",
    "These preintegrated measurements are independent of the absolute pose/velocity at time $i$, which allows efficient re-linearization during optimization."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-10",
   "metadata": {},
   "outputs": [],
   "source": [
    "def preintegrate_imu(\n",
    "    accel_meas: jax.Array,  # (n_measurements, 3)\n",
    "    gyro_meas: jax.Array,  # (n_measurements, 3)\n",
    "    accel_bias: jax.Array,  # (3,)\n",
    "    gyro_bias: jax.Array,  # (3,)\n",
    "    dt: float,\n",
    ") -> tuple[jaxlie.SO3, jax.Array, jax.Array]:\n",
    "    \"\"\"Preintegrate IMU measurements between two keyframes.\n",
    "\n",
    "    Args:\n",
    "        accel_meas: Accelerometer measurements (n_measurements, 3)\n",
    "        gyro_meas: Gyroscope measurements (n_measurements, 3)\n",
    "        accel_bias: Accelerometer bias (3,)\n",
    "        gyro_bias: Gyroscope bias (3,)\n",
    "        dt: Time step between measurements\n",
    "\n",
    "    Returns:\n",
    "        Tuple of (delta_R, delta_v, delta_p):\n",
    "            delta_R: Relative rotation (SO3)\n",
    "            delta_v: Velocity increment in body frame (3,)\n",
    "            delta_p: Position increment in body frame (3,)\n",
    "    \"\"\"\n",
    "    # Bias-corrected measurements\n",
    "    accel_corrected = accel_meas - accel_bias[None, :]\n",
    "    gyro_corrected = gyro_meas - gyro_bias[None, :]\n",
    "\n",
    "    # Initialize preintegrated values\n",
    "    delta_R = jaxlie.SO3.identity()\n",
    "    delta_v = jnp.zeros(3)\n",
    "    delta_p = jnp.zeros(3)\n",
    "\n",
    "    def step(\n",
    "        carry: tuple[jaxlie.SO3, jax.Array, jax.Array],\n",
    "        inputs: tuple[jax.Array, jax.Array],\n",
    "    ) -> tuple[tuple[jaxlie.SO3, jax.Array, jax.Array], None]:\n",
    "        delta_R, delta_v, delta_p = carry\n",
    "        accel, gyro = inputs\n",
    "\n",
    "        # Integrate rotation: delta_R = delta_R * Exp(omega * dt)\n",
    "        delta_R_new = delta_R @ jaxlie.SO3.exp(gyro * dt)\n",
    "\n",
    "        # Rotate acceleration to preintegration frame\n",
    "        accel_rotated = delta_R @ accel\n",
    "\n",
    "        # Integrate velocity and position\n",
    "        delta_p_new = delta_p + delta_v * dt + 0.5 * accel_rotated * dt**2\n",
    "        delta_v_new = delta_v + accel_rotated * dt\n",
    "\n",
    "        return (delta_R_new, delta_v_new, delta_p_new), None\n",
    "\n",
    "    (delta_R, delta_v, delta_p), _ = jax.lax.scan(\n",
    "        step, (delta_R, delta_v, delta_p), (accel_corrected, gyro_corrected)\n",
    "    )\n",
    "\n",
    "    return delta_R, delta_v, delta_p\n",
    "\n",
    "\n",
    "# Test preintegration with true bias\n",
    "delta_R_test, delta_v_test, delta_p_test = preintegrate_imu(\n",
    "    accel_measurements[0], gyro_measurements[0], true_accel_bias, true_gyro_bias, imu_dt\n",
    ")\n",
    "print(\"Test preintegration:\")\n",
    "print(f\"  delta_R: {delta_R_test.log()}\")\n",
    "print(f\"  delta_v: {delta_v_test}\")\n",
    "print(f\"  delta_p: {delta_p_test}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-11",
   "metadata": {},
   "source": "## Cost functions\n\nWe define three types of costs:\n1. IMU preintegration cost: Constrains consecutive pose/velocity pairs based on integrated IMU measurements\n2. Prior cost: Anchors the first pose and velocity\n3. Bias random walk cost: Keeps bias estimates slowly varying"
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-12",
   "metadata": {},
   "outputs": [],
   "source": [
    "@jaxls.Cost.factory\n",
    "def imu_cost(\n",
    "    vals: jaxls.VarValues,\n",
    "    pose_i: jaxls.SE3Var,\n",
    "    vel_i: VelocityVar,\n",
    "    pose_j: jaxls.SE3Var,\n",
    "    vel_j: VelocityVar,\n",
    "    bias: BiasVar,\n",
    "    accel_meas: jax.Array,\n",
    "    gyro_meas: jax.Array,\n",
    "    dt_total: float,\n",
    "    dt_imu: float,\n",
    "    gravity: jax.Array,\n",
    ") -> jax.Array:\n",
    "    \"\"\"IMU preintegration cost between two keyframes.\n",
    "\n",
    "    Computes residual between predicted and measured relative motion.\n",
    "    \"\"\"\n",
    "    # Get current estimates\n",
    "    T_i = vals[pose_i]\n",
    "    T_j = vals[pose_j]\n",
    "    v_i = vals[vel_i]\n",
    "    v_j = vals[vel_j]\n",
    "    b = vals[bias]\n",
    "    accel_bias, gyro_bias = b[:3], b[3:]\n",
    "\n",
    "    R_i = T_i.rotation()\n",
    "    p_i = T_i.translation()\n",
    "    R_j = T_j.rotation()\n",
    "    p_j = T_j.translation()\n",
    "\n",
    "    # Preintegrate with current bias estimate\n",
    "    delta_R, delta_v, delta_p = preintegrate_imu(\n",
    "        accel_meas, gyro_meas, accel_bias, gyro_bias, dt_imu\n",
    "    )\n",
    "\n",
    "    # Predicted relative motion from states\n",
    "    # Position: p_j = p_i + v_i * dt + 0.5 * g * dt^2 + R_i * delta_p\n",
    "    p_j_pred = p_i + v_i * dt_total + 0.5 * gravity * dt_total**2 + R_i @ delta_p\n",
    "\n",
    "    # Velocity: v_j = v_i + g * dt + R_i * delta_v\n",
    "    v_j_pred = v_i + gravity * dt_total + R_i @ delta_v\n",
    "\n",
    "    # Rotation: R_j = R_i * delta_R\n",
    "    R_j_pred = R_i @ delta_R\n",
    "\n",
    "    # Compute residuals\n",
    "    # Position residual (meters)\n",
    "    r_p = (p_j - p_j_pred) * 10.0\n",
    "\n",
    "    # Velocity residual (m/s)\n",
    "    r_v = (v_j - v_j_pred) * 10.0\n",
    "\n",
    "    # Rotation residual (radians) - weight higher since gyro is more accurate\n",
    "    r_R = (R_j_pred.inverse() @ R_j).log() * 100.0\n",
    "\n",
    "    return jnp.concatenate([r_p, r_v, r_R])\n",
    "\n",
    "\n",
    "@jaxls.Cost.factory\n",
    "def pose_prior_cost(\n",
    "    vals: jaxls.VarValues,\n",
    "    var: jaxls.SE3Var,\n",
    "    target: jaxlie.SE3,\n",
    ") -> jax.Array:\n",
    "    \"\"\"Prior on SE3 pose (both position and orientation).\"\"\"\n",
    "    error = (vals[var].inverse() @ target).log()\n",
    "    # Weight position and rotation\n",
    "    return jnp.concatenate(\n",
    "        [\n",
    "            error[:3] * 50.0,  # Translation (meters)\n",
    "            error[3:] * 100.0,  # Rotation (radians)\n",
    "        ]\n",
    "    )\n",
    "\n",
    "\n",
    "@jaxls.Cost.factory\n",
    "def velocity_prior_cost(\n",
    "    vals: jaxls.VarValues,\n",
    "    var: VelocityVar,\n",
    "    target: jax.Array,\n",
    ") -> jax.Array:\n",
    "    \"\"\"Prior on velocity.\"\"\"\n",
    "    return (vals[var] - target) * 50.0\n",
    "\n",
    "\n",
    "@jaxls.Cost.factory\n",
    "def bias_prior_cost(\n",
    "    vals: jaxls.VarValues,\n",
    "    var: BiasVar,\n",
    "    target: jax.Array,\n",
    ") -> jax.Array:\n",
    "    \"\"\"Prior on IMU bias (weak, allows estimation).\"\"\"\n",
    "    # Very weak prior - we want the bias to be estimated from IMU residuals\n",
    "    return (vals[var] - target) * 0.1"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-13",
   "metadata": {},
   "source": "## Solving"
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-14",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Create variables\n",
    "pose_vars = jaxls.SE3Var(id=jnp.arange(n_keyframes))\n",
    "vel_vars = VelocityVar(id=jnp.arange(n_keyframes))\n",
    "bias_var = BiasVar(id=0)  # Single bias variable (assumed constant)\n",
    "\n",
    "# Sparse GPS-like position priors (e.g., from occasional GPS fixes)\n",
    "# These provide just enough constraint for bias observability\n",
    "gps_interval = 10  # GPS fix every 10 keyframes (5 seconds)\n",
    "gps_indices = jnp.arange(0, n_keyframes, gps_interval)\n",
    "gps_poses = jaxlie.SE3(wxyz_xyz=true_poses.wxyz_xyz[gps_indices])\n",
    "\n",
    "# IMU cost indices (consecutive keyframe pairs)\n",
    "n_intervals = n_keyframes - 1\n",
    "imu_i_ids = jnp.arange(n_intervals)\n",
    "imu_j_ids = jnp.arange(1, n_keyframes)\n",
    "\n",
    "# Tile scalar parameters for batching\n",
    "gravity_batched = jnp.tile(gravity[None, :], (n_intervals, 1))\n",
    "\n",
    "# Build costs using batched construction\n",
    "costs: list[jaxls.Cost] = [\n",
    "    # Sparse GPS pose priors\n",
    "    pose_prior_cost(jaxls.SE3Var(id=gps_indices), gps_poses),\n",
    "    # Anchor start velocity\n",
    "    velocity_prior_cost(VelocityVar(id=0), true_velocities[0]),\n",
    "    # Weak prior on bias (centered at zero)\n",
    "    bias_prior_cost(bias_var, jnp.zeros(6)),\n",
    "    # IMU preintegration costs between consecutive keyframes (batched)\n",
    "    imu_cost(\n",
    "        jaxls.SE3Var(id=imu_i_ids),\n",
    "        VelocityVar(id=imu_i_ids),\n",
    "        jaxls.SE3Var(id=imu_j_ids),\n",
    "        VelocityVar(id=imu_j_ids),\n",
    "        bias_var,\n",
    "        accel_measurements,\n",
    "        gyro_measurements,\n",
    "        keyframe_dt,\n",
    "        imu_dt,\n",
    "        gravity_batched,\n",
    "    ),\n",
    "]\n",
    "\n",
    "print(f\"Created {len(costs)} batched cost objects\")\n",
    "print(f\"GPS priors at keyframes: {list(gps_indices)} (every {gps_interval} keyframes)\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-15",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Initial values: first pose/velocity from prior, rest from dead reckoning\n",
    "# We start with zero bias estimate\n",
    "\n",
    "\n",
    "@jax.jit\n",
    "def dead_reckon_trajectory(\n",
    "    initial_pose: jaxlie.SE3,\n",
    "    initial_vel: jax.Array,\n",
    "    accel_meas: jax.Array,\n",
    "    gyro_meas: jax.Array,\n",
    ") -> tuple[jaxlie.SE3, jax.Array]:\n",
    "    \"\"\"Dead reckon forward with zero bias assumption (vectorized with scan).\n",
    "\n",
    "    Args:\n",
    "        initial_pose: Starting pose\n",
    "        initial_vel: Starting velocity (3,)\n",
    "        accel_meas: Accelerometer measurements (n_intervals, n_measurements, 3)\n",
    "        gyro_meas: Gyroscope measurements (n_intervals, n_measurements, 3)\n",
    "\n",
    "    Returns:\n",
    "        Tuple of (poses, velocities) for all keyframes\n",
    "    \"\"\"\n",
    "    zero_bias = jnp.zeros(3)\n",
    "\n",
    "    def step(\n",
    "        carry: tuple[jaxlie.SE3, jax.Array],\n",
    "        inputs: tuple[jax.Array, jax.Array],\n",
    "    ) -> tuple[tuple[jaxlie.SE3, jax.Array], tuple[jax.Array, jax.Array]]:\n",
    "        pose, vel = carry\n",
    "        accel, gyro = inputs\n",
    "\n",
    "        # Preintegrate this interval\n",
    "        delta_R, delta_v, delta_p = preintegrate_imu(\n",
    "            accel, gyro, zero_bias, zero_bias, imu_dt\n",
    "        )\n",
    "\n",
    "        R_i = pose.rotation()\n",
    "        p_i = pose.translation()\n",
    "\n",
    "        # Propagate\n",
    "        p_next = (\n",
    "            p_i + vel * keyframe_dt + 0.5 * gravity * keyframe_dt**2 + R_i @ delta_p\n",
    "        )\n",
    "        v_next = vel + gravity * keyframe_dt + R_i @ delta_v\n",
    "        R_next = R_i @ delta_R\n",
    "\n",
    "        next_pose = jaxlie.SE3.from_rotation_and_translation(R_next, p_next)\n",
    "        return (next_pose, v_next), (next_pose.wxyz_xyz, v_next)\n",
    "\n",
    "    initial_carry = (initial_pose, initial_vel)\n",
    "    _, (pose_wxyz_xyz, velocities) = jax.lax.scan(\n",
    "        step, initial_carry, (accel_meas, gyro_meas)\n",
    "    )\n",
    "\n",
    "    # Prepend initial state\n",
    "    all_poses = jaxlie.SE3(\n",
    "        wxyz_xyz=jnp.concatenate([initial_pose.wxyz_xyz[None], pose_wxyz_xyz])\n",
    "    )\n",
    "    all_velocities = jnp.concatenate([initial_vel[None], velocities])\n",
    "\n",
    "    return all_poses, all_velocities\n",
    "\n",
    "\n",
    "# Get initial pose and velocity from ground truth\n",
    "initial_pose = jaxlie.SE3(wxyz_xyz=true_poses.wxyz_xyz[0])\n",
    "initial_vel = true_velocities[0]\n",
    "\n",
    "initial_poses, initial_velocities = dead_reckon_trajectory(\n",
    "    initial_pose, initial_vel, accel_measurements, gyro_measurements\n",
    ")\n",
    "\n",
    "print(f\"Initial dead-reckoned end position: {initial_poses.translation()[-1]}\")\n",
    "print(f\"True end position: {true_poses.translation()[-1]}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-16",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Create initial values\n",
    "initial_vals = jaxls.VarValues.make(\n",
    "    [\n",
    "        pose_vars.with_value(initial_poses),\n",
    "        vel_vars.with_value(initial_velocities),\n",
    "        bias_var.with_value(jnp.zeros(6)),\n",
    "    ]\n",
    ")\n",
    "\n",
    "# Build and solve problem\n",
    "problem = jaxls.LeastSquaresProblem(costs, [pose_vars, vel_vars, bias_var]).analyze()\n",
    "\n",
    "solution = problem.solve(\n",
    "    initial_vals,\n",
    "    termination=jaxls.TerminationConfig(cost_tolerance=1e-8),\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-17",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Extract results\n",
    "estimated_poses = solution[pose_vars]\n",
    "estimated_velocities = solution[vel_vars]\n",
    "estimated_bias = solution[bias_var]\n",
    "\n",
    "print(\"Bias estimation:\")\n",
    "print(f\"  True:      accel={true_accel_bias}, gyro={true_gyro_bias}\")\n",
    "print(f\"  Estimated: accel={estimated_bias[:3]}, gyro={estimated_bias[3:]}\")\n",
    "print(\n",
    "    f\"  Error:     accel={jnp.abs(estimated_bias[:3] - true_accel_bias)}, \"\n",
    "    f\"gyro={jnp.abs(estimated_bias[3:] - true_gyro_bias)}\"\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-18",
   "metadata": {},
   "source": [
    "## Visualization\n",
    "\n",
    "Compare the estimated trajectory with ground truth and the dead-reckoned initialization:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-19",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Extract positions\n",
    "true_positions = np.array(true_poses.translation())\n",
    "initial_positions = np.array(initial_poses.translation())\n",
    "estimated_positions = np.array(estimated_poses.translation())\n",
    "\n",
    "# Compute errors\n",
    "position_errors = jnp.linalg.norm(\n",
    "    estimated_poses.translation() - true_poses.translation(), axis=-1\n",
    ")\n",
    "print(\n",
    "    f\"Position errors: mean={float(jnp.mean(position_errors)):.4f}m, \"\n",
    "    f\"max={float(jnp.max(position_errors)):.4f}m\"\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-20",
   "metadata": {
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "fig = go.Figure()\n",
    "\n",
    "# Ground truth trajectory\n",
    "fig.add_trace(\n",
    "    go.Scatter3d(\n",
    "        x=true_positions[:, 0],\n",
    "        y=true_positions[:, 1],\n",
    "        z=true_positions[:, 2],\n",
    "        mode=\"lines+markers\",\n",
    "        line=dict(color=\"forestgreen\", width=4),\n",
    "        marker=dict(size=4, color=\"forestgreen\"),\n",
    "        name=\"Ground truth\",\n",
    "        hovertemplate=\"GT: (%{x:.2f}, %{y:.2f}, %{z:.2f})<extra></extra>\",\n",
    "    )\n",
    ")\n",
    "\n",
    "# Dead-reckoned (initial) trajectory\n",
    "fig.add_trace(\n",
    "    go.Scatter3d(\n",
    "        x=initial_positions[:, 0],\n",
    "        y=initial_positions[:, 1],\n",
    "        z=initial_positions[:, 2],\n",
    "        mode=\"lines+markers\",\n",
    "        line=dict(color=\"tomato\", width=2, dash=\"dash\"),\n",
    "        marker=dict(size=3, color=\"tomato\"),\n",
    "        name=\"Dead reckoning (init)\",\n",
    "        hovertemplate=\"Init: (%{x:.2f}, %{y:.2f}, %{z:.2f})<extra></extra>\",\n",
    "    )\n",
    ")\n",
    "\n",
    "# Optimized trajectory\n",
    "fig.add_trace(\n",
    "    go.Scatter3d(\n",
    "        x=estimated_positions[:, 0],\n",
    "        y=estimated_positions[:, 1],\n",
    "        z=estimated_positions[:, 2],\n",
    "        mode=\"lines+markers\",\n",
    "        line=dict(color=\"steelblue\", width=4),\n",
    "        marker=dict(size=5, color=\"steelblue\"),\n",
    "        name=\"Optimized\",\n",
    "        hovertemplate=\"Opt: (%{x:.2f}, %{y:.2f}, %{z:.2f})<extra></extra>\",\n",
    "    )\n",
    ")\n",
    "\n",
    "# Start marker\n",
    "fig.add_trace(\n",
    "    go.Scatter3d(\n",
    "        x=[true_positions[0, 0]],\n",
    "        y=[true_positions[0, 1]],\n",
    "        z=[true_positions[0, 2]],\n",
    "        mode=\"markers\",\n",
    "        marker=dict(size=10, color=\"green\", symbol=\"diamond\"),\n",
    "        name=\"Start\",\n",
    "        hovertemplate=\"Start<extra></extra>\",\n",
    "    )\n",
    ")\n",
    "\n",
    "# Layout\n",
    "fig.update_layout(\n",
    "    scene=dict(\n",
    "        xaxis=dict(title=\"X (m)\", showbackground=False),\n",
    "        yaxis=dict(title=\"Y (m)\", showbackground=False),\n",
    "        zaxis=dict(title=\"Z (m)\", showbackground=False),\n",
    "        aspectmode=\"data\",\n",
    "        camera=dict(eye=dict(x=1.5, y=1.5, z=1.0)),\n",
    "    ),\n",
    "    height=550,\n",
    "    margin=dict(t=30, b=20, l=20, r=20),\n",
    "    legend=dict(x=0.02, y=0.98, bgcolor=\"rgba(255,255,255,0.8)\"),\n",
    ")\n",
    "\n",
    "HTML(fig.to_html(full_html=False, include_plotlyjs=\"cdn\"))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-21",
   "metadata": {},
   "source": "## Key observations\n\nThe optimizer jointly estimates poses, velocities, and IMU biases by minimizing residuals between predicted and measured relative motion:\n\n- **Bias calibration**: Accelerometer bias becomes observable because gravity projects differently onto accelerometer axes at varied orientations. With roll and pitch changes throughout the trajectory, the optimizer can separate true acceleration from constant bias.\n\n- **Trajectory correction**: Dead reckoning (red dashed) drifts due to the biased IMU measurements. The optimizer corrects this drift to match the ground truth (green).\n\n- **Preintegration efficiency**: The relative motion constraints between keyframes are computed once from raw IMU data and reused during optimization."
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}