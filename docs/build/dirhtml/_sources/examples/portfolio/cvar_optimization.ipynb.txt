{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "cell-0",
   "metadata": {},
   "source": "# CVaR Allocation\n\nMinimizing Conditional Value at Risk (CVaR) for tail-risk-aware portfolio allocation.\n\nUnlike mean-variance optimization which penalizes all volatility equally, CVaR focuses on\nworst-case scenarios -- the expected loss in the worst \u03b1% of outcomes. This makes\nit useful for risk-averse investors concerned about extreme market downturns.\n\nThis example is based on the formulation from [PyPortfolioOpt](https://pyportfolioopt.readthedocs.io/en/latest/GeneralEfficientFrontier.html)\nand [Rockafellar & Uryasev (2000)](https://sites.math.washington.edu/~rtr/papers/rtr179-CVaR1.pdf).\n\nFeatures used:\n- {class}`~jaxls.Var` with vector-valued and scalar defaults\n- Inequality constraints (`constraint_geq_zero`): CVaR auxiliary constraints, budget, no short-selling\n- Equality constraints (`constraint_eq_zero`): budget constraint\n- Augmented Lagrangian solver for constrained optimization"
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-1",
   "metadata": {
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "import sys\n",
    "from loguru import logger\n",
    "\n",
    "logger.remove()\n",
    "logger.add(sys.stdout, format=\"<level>{level: <8}</level> | {message}\");"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-2",
   "metadata": {},
   "outputs": [],
   "source": [
    "import jax\n",
    "import jax.numpy as jnp\n",
    "import jaxls"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-3",
   "metadata": {},
   "source": "## Historical stock data\n\nWe use the same dataset as the {doc}`mean_variance` example:\nmonthly stock prices from November 2000 to November 2001 for IBM, Walmart (WMT),\nand Southern Electric (SEHI)."
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-4",
   "metadata": {},
   "outputs": [],
   "source": [
    "stock_names = [\"IBM\", \"WMT\", \"SEHI\"]\n",
    "\n",
    "# Monthly prices (13 months: Nov 2000 - Nov 2001)\n",
    "prices = jnp.array(\n",
    "    [\n",
    "        [93.043, 51.826, 1.063],\n",
    "        [84.585, 52.823, 0.938],\n",
    "        [111.453, 56.477, 1.0],\n",
    "        [99.525, 49.805, 0.938],\n",
    "        [95.819, 50.287, 1.438],\n",
    "        [114.708, 51.521, 1.7],\n",
    "        [111.515, 51.531, 2.54],\n",
    "        [113.211, 48.664, 2.39],\n",
    "        [104.942, 55.744, 3.12],\n",
    "        [99.827, 47.916, 2.98],\n",
    "        [91.607, 49.438, 1.9],\n",
    "        [107.937, 51.336, 1.75],\n",
    "        [115.59, 55.081, 1.8],\n",
    "    ]\n",
    ")\n",
    "\n",
    "# Monthly returns: (P[t+1] - P[t]) / P[t]\n",
    "returns = jnp.diff(prices, axis=0) / prices[:-1]\n",
    "num_scenarios, num_assets = returns.shape\n",
    "\n",
    "print(\n",
    "    f\"Returns shape: {returns.shape} ({num_scenarios} scenarios x {num_assets} assets)\"\n",
    ")\n",
    "print(f\"\\nMonthly returns (%):\\n{returns * 100}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-5",
   "metadata": {},
   "source": "## CVaR vs variance\n\nVariance measures average deviation from the mean -- it penalizes upside and downside equally.\n\nCVaR (Conditional Value at Risk) measures the expected loss in the worst $\\alpha\\%$ of scenarios.\nFor $\\alpha = 0.05$ (95% confidence), CVaR answers: \"What's my average loss on the worst 5% of days?\"\n\nKey advantages of CVaR:\n- Focuses on tail risk (extreme losses) rather than general volatility\n- Coherent risk measure (subadditive, convex)\n- Does not assume normally distributed returns\n- More robust to outliers than variance"
  },
  {
   "cell_type": "markdown",
   "id": "cell-6",
   "metadata": {},
   "source": [
    "## CVaR formulation\n",
    "\n",
    "The CVaR optimization uses the Rockafellar-Uryasev formulation:\n",
    "\n",
    "$$\\text{CVaR}_\\alpha = \\min_{\\zeta} \\left[ \\zeta + \\frac{1}{\\alpha T} \\sum_{t=1}^T \\max(-w^\\top r_t - \\zeta, 0) \\right]$$\n",
    "\n",
    "where:\n",
    "- $w$ = portfolio weights\n",
    "- $r_t$ = returns in scenario $t$\n",
    "- $\\zeta$ = VaR threshold (auxiliary variable)\n",
    "- $\\alpha$ = tail probability (e.g., 0.05 for 95% CVaR)\n",
    "- $T$ = number of scenarios\n",
    "\n",
    "To handle the $\\max(\\cdot, 0)$ term, we introduce slack variables $u_t \\geq 0$:\n",
    "\n",
    "$$\\min_{w, \\zeta, u} \\quad \\zeta + \\frac{1}{\\alpha T} \\sum_{t=1}^T u_t$$\n",
    "\n",
    "subject to:\n",
    "- $u_t \\geq -w^\\top r_t - \\zeta$ (loss exceeds VaR)\n",
    "- $u_t \\geq 0$ (slack non-negativity)\n",
    "- $\\sum_i w_i = 1$ (budget constraint)\n",
    "- $w_i \\geq 0$ (no short-selling)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-7",
   "metadata": {},
   "outputs": [],
   "source": [
    "# CVaR confidence level.\n",
    "alpha = 0.05  # 95% CVaR (worst 5% of scenarios)\n",
    "\n",
    "\n",
    "class WeightsVar(jaxls.Var[jax.Array], default_factory=lambda: jnp.ones(3) / 3):\n",
    "    \"\"\"Portfolio weights (3D vector).\"\"\"\n",
    "\n",
    "\n",
    "class VaRVar(jaxls.Var[jax.Array], default_factory=lambda: jnp.zeros(1)):\n",
    "    \"\"\"Value-at-Risk threshold (scalar).\"\"\"\n",
    "\n",
    "\n",
    "class SlackVar(jaxls.Var[jax.Array], default_factory=lambda: jnp.zeros(12)):\n",
    "    \"\"\"Slack variables for max(loss - VaR, 0) per scenario.\"\"\"\n",
    "\n",
    "\n",
    "weights_var = WeightsVar(id=0)\n",
    "var_var = VaRVar(id=0)\n",
    "slack_var = SlackVar(id=0)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-8",
   "metadata": {},
   "outputs": [],
   "source": [
    "@jaxls.Cost.factory\n",
    "def cvar_objective(\n",
    "    vals: jaxls.VarValues,\n",
    "    var_v: VaRVar,\n",
    "    slack_v: SlackVar,\n",
    "    alpha: float,\n",
    "    num_scenarios: int,\n",
    ") -> jax.Array:\n",
    "    \"\"\"CVaR objective: VaR + (1/alpha) * mean(slack).\n",
    "\n",
    "    Since this is the only cost term, the solver minimizes CVaR^2. For a\n",
    "    non-negative scalar, min(CVaR^2) has the same minimizer as min(CVaR).\n",
    "    \"\"\"\n",
    "    var_threshold = vals[var_v]\n",
    "    slack = vals[slack_v]\n",
    "    return var_threshold + jnp.sum(slack) / (alpha * num_scenarios)\n",
    "\n",
    "\n",
    "@jaxls.Cost.factory(kind=\"constraint_geq_zero\")\n",
    "def slack_lower_bound(\n",
    "    vals: jaxls.VarValues,\n",
    "    weights_v: WeightsVar,\n",
    "    var_v: VaRVar,\n",
    "    slack_v: SlackVar,\n",
    "    scenario_returns: jax.Array,\n",
    ") -> jax.Array:\n",
    "    \"\"\"Constraint: u_t >= -w'r_t - zeta (slack captures excess loss).\"\"\"\n",
    "    weights = vals[weights_v]\n",
    "    var_threshold = vals[var_v]\n",
    "    slack = vals[slack_v]\n",
    "    # Portfolio return for each scenario.\n",
    "    portfolio_returns = scenario_returns @ weights\n",
    "    # Loss = negative return.\n",
    "    losses = -portfolio_returns\n",
    "    # u_t >= loss_t - VaR.\n",
    "    return slack - (losses - var_threshold)\n",
    "\n",
    "\n",
    "@jaxls.Cost.factory(kind=\"constraint_geq_zero\")\n",
    "def slack_nonneg(vals: jaxls.VarValues, slack_v: SlackVar) -> jax.Array:\n",
    "    \"\"\"Constraint: u_t >= 0.\"\"\"\n",
    "    return vals[slack_v]\n",
    "\n",
    "\n",
    "@jaxls.Cost.factory(kind=\"constraint_eq_zero\")\n",
    "def budget_constraint(vals: jaxls.VarValues, weights_v: WeightsVar) -> jax.Array:\n",
    "    \"\"\"Weights must sum to 1 (fully invested).\"\"\"\n",
    "    return jnp.sum(vals[weights_v]) - 1.0\n",
    "\n",
    "\n",
    "@jaxls.Cost.factory(kind=\"constraint_geq_zero\")\n",
    "def no_short_constraint(vals: jaxls.VarValues, weights_v: WeightsVar) -> jax.Array:\n",
    "    \"\"\"No short-selling: weights >= 0.\"\"\"\n",
    "    return vals[weights_v]"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-9",
   "metadata": {},
   "source": "## Solving"
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-10",
   "metadata": {},
   "outputs": [],
   "source": [
    "costs = [\n",
    "    cvar_objective(var_var, slack_var, alpha, num_scenarios),\n",
    "    slack_lower_bound(weights_var, var_var, slack_var, returns),\n",
    "    slack_nonneg(slack_var),\n",
    "    budget_constraint(weights_var),\n",
    "    no_short_constraint(weights_var),\n",
    "]\n",
    "\n",
    "problem = jaxls.LeastSquaresProblem(costs, [weights_var, var_var, slack_var]).analyze()\n",
    "\n",
    "solution = problem.solve(\n",
    "    verbose=True,\n",
    "    linear_solver=\"dense_cholesky\",\n",
    "    termination=jaxls.TerminationConfig(cost_tolerance=1e-8),\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-11",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Extract solution.\n",
    "optimal_weights = solution[weights_var]\n",
    "optimal_var = float(solution[var_var][0])\n",
    "\n",
    "# Compute CVaR from the solution.\n",
    "portfolio_returns = returns @ optimal_weights\n",
    "losses = -portfolio_returns\n",
    "# CVaR is the mean of losses exceeding VaR.\n",
    "tail_losses = jnp.where(losses >= optimal_var, losses, 0.0)\n",
    "cvar_value = optimal_var + jnp.sum(jnp.maximum(losses - optimal_var, 0)) / (\n",
    "    alpha * num_scenarios\n",
    ")\n",
    "\n",
    "print(\"\\n=== CVaR-Optimal Portfolio ===\")\n",
    "print(f\"\\nAlpha (tail probability): {alpha:.0%}\")\n",
    "print(\"\\nOptimal weights:\")\n",
    "for name, w in zip(stock_names, optimal_weights):\n",
    "    print(f\"  {name}: {float(w) * 100:.1f}%\")\n",
    "print(f\"\\nVaR (95%): {optimal_var * 100:.2f}% monthly loss\")\n",
    "print(\n",
    "    f\"CVaR (95%): {float(cvar_value) * 100:.2f}% expected loss in worst {alpha:.0%} of scenarios\"\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-12",
   "metadata": {},
   "source": "## Comparison: CVaR vs mean-variance\n\nLet's compare the CVaR-optimal portfolio with a minimum-variance portfolio."
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-13",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Compute covariance matrix for mean-variance comparison.\n",
    "expected_returns = jnp.mean(returns, axis=0)\n",
    "returns_centered = returns - expected_returns\n",
    "covariance = (returns_centered.T @ returns_centered) / (returns.shape[0] - 1)\n",
    "cov_chol = jnp.linalg.cholesky(covariance)\n",
    "\n",
    "\n",
    "class MVWeightsVar(jaxls.Var[jax.Array], default_factory=lambda: jnp.ones(3) / 3):\n",
    "    \"\"\"Portfolio weights for mean-variance optimization.\"\"\"\n",
    "\n",
    "\n",
    "@jaxls.Cost.factory\n",
    "def variance_cost(\n",
    "    vals: jaxls.VarValues, var: MVWeightsVar, cov_chol: jax.Array\n",
    ") -> jax.Array:\n",
    "    \"\"\"Minimize portfolio variance: ||L.T @ w||^2 = w.T @ cov @ w.\"\"\"\n",
    "    return cov_chol.T @ vals[var]\n",
    "\n",
    "\n",
    "@jaxls.Cost.factory(kind=\"constraint_eq_zero\")\n",
    "def mv_budget_constraint(vals: jaxls.VarValues, var: MVWeightsVar) -> jax.Array:\n",
    "    \"\"\"Weights must sum to 1.\"\"\"\n",
    "    return jnp.sum(vals[var]) - 1.0\n",
    "\n",
    "\n",
    "@jaxls.Cost.factory(kind=\"constraint_geq_zero\")\n",
    "def mv_no_short_constraint(vals: jaxls.VarValues, var: MVWeightsVar) -> jax.Array:\n",
    "    \"\"\"No short-selling.\"\"\"\n",
    "    return vals[var]\n",
    "\n",
    "\n",
    "mv_weights_var = MVWeightsVar(id=0)\n",
    "mv_costs = [\n",
    "    variance_cost(mv_weights_var, cov_chol),\n",
    "    mv_budget_constraint(mv_weights_var),\n",
    "    mv_no_short_constraint(mv_weights_var),\n",
    "]\n",
    "\n",
    "mv_problem = jaxls.LeastSquaresProblem(mv_costs, [mv_weights_var]).analyze()\n",
    "mv_solution = mv_problem.solve(\n",
    "    verbose=False,\n",
    "    linear_solver=\"dense_cholesky\",\n",
    "    termination=jaxls.TerminationConfig(cost_tolerance=1e-8),\n",
    ")\n",
    "\n",
    "mv_weights = mv_solution[mv_weights_var]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-14",
   "metadata": {
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "import plotly.graph_objects as go\n",
    "from plotly.subplots import make_subplots\n",
    "from IPython.display import HTML\n",
    "\n",
    "\n",
    "def compute_metrics(weights: jax.Array) -> dict:\n",
    "    \"\"\"Compute risk metrics for a portfolio.\"\"\"\n",
    "    port_returns = returns @ weights\n",
    "    losses = -port_returns\n",
    "\n",
    "    # Variance and std dev.\n",
    "    variance = float(weights @ covariance @ weights)\n",
    "    std_dev = float(jnp.sqrt(variance))\n",
    "\n",
    "    # VaR (95%) - the 95th percentile of losses.\n",
    "    sorted_losses = jnp.sort(losses)\n",
    "    var_95 = float(sorted_losses[int(num_scenarios * (1 - alpha))])\n",
    "\n",
    "    # CVaR (95%) - mean of losses exceeding VaR.\n",
    "    cvar_95 = float(\n",
    "        var_95 + jnp.sum(jnp.maximum(losses - var_95, 0)) / (alpha * num_scenarios)\n",
    "    )\n",
    "\n",
    "    # Expected return.\n",
    "    exp_return = float(jnp.dot(weights, expected_returns))\n",
    "\n",
    "    return {\n",
    "        \"std_dev\": std_dev,\n",
    "        \"var_95\": var_95,\n",
    "        \"cvar_95\": cvar_95,\n",
    "        \"exp_return\": exp_return,\n",
    "    }\n",
    "\n",
    "\n",
    "cvar_metrics = compute_metrics(optimal_weights)\n",
    "mv_metrics = compute_metrics(mv_weights)\n",
    "\n",
    "print(\"=\" * 50)\n",
    "print(f\"{'Metric':<25} {'CVaR-Opt':>12} {'Min-Var':>12}\")\n",
    "print(\"=\" * 50)\n",
    "print(\n",
    "    f\"{'Expected Return (monthly)':<25} {cvar_metrics['exp_return'] * 100:>11.2f}% {mv_metrics['exp_return'] * 100:>11.2f}%\"\n",
    ")\n",
    "print(\n",
    "    f\"{'Std Dev (monthly)':<25} {cvar_metrics['std_dev'] * 100:>11.2f}% {mv_metrics['std_dev'] * 100:>11.2f}%\"\n",
    ")\n",
    "print(\n",
    "    f\"{'VaR 95% (monthly loss)':<25} {cvar_metrics['var_95'] * 100:>11.2f}% {mv_metrics['var_95'] * 100:>11.2f}%\"\n",
    ")\n",
    "print(\n",
    "    f\"{'CVaR 95% (monthly loss)':<25} {cvar_metrics['cvar_95'] * 100:>11.2f}% {mv_metrics['cvar_95'] * 100:>11.2f}%\"\n",
    ")\n",
    "print(\"=\" * 50)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-15",
   "metadata": {
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "colors = [\"#2196F3\", \"#4CAF50\", \"#FF9800\"]\n",
    "\n",
    "fig = make_subplots(\n",
    "    rows=1,\n",
    "    cols=2,\n",
    "    subplot_titles=(\"Portfolio Weights\", \"Return Distribution\"),\n",
    "    column_widths=[0.4, 0.6],\n",
    ")\n",
    "\n",
    "# Left plot: Weight comparison.\n",
    "x_labels = stock_names\n",
    "fig.add_trace(\n",
    "    go.Bar(\n",
    "        x=x_labels,\n",
    "        y=optimal_weights * 100,\n",
    "        name=\"CVaR-Optimal\",\n",
    "        marker_color=\"#E91E63\",\n",
    "    ),\n",
    "    row=1,\n",
    "    col=1,\n",
    ")\n",
    "fig.add_trace(\n",
    "    go.Bar(\n",
    "        x=x_labels,\n",
    "        y=mv_weights * 100,\n",
    "        name=\"Min-Variance\",\n",
    "        marker_color=\"#3F51B5\",\n",
    "    ),\n",
    "    row=1,\n",
    "    col=1,\n",
    ")\n",
    "\n",
    "# Right plot: Return distributions.\n",
    "cvar_returns = returns @ optimal_weights\n",
    "mv_returns = returns @ mv_weights\n",
    "\n",
    "# Sort for visualization.\n",
    "sorted_idx = jnp.argsort(cvar_returns)\n",
    "scenario_labels = [f\"Scenario {i + 1}\" for i in range(num_scenarios)]\n",
    "\n",
    "fig.add_trace(\n",
    "    go.Bar(\n",
    "        x=list(range(num_scenarios)),\n",
    "        y=cvar_returns[sorted_idx] * 100,\n",
    "        name=\"CVaR-Optimal Returns\",\n",
    "        marker_color=\"#E91E63\",\n",
    "        opacity=0.7,\n",
    "    ),\n",
    "    row=1,\n",
    "    col=2,\n",
    ")\n",
    "fig.add_trace(\n",
    "    go.Bar(\n",
    "        x=list(range(num_scenarios)),\n",
    "        y=mv_returns[sorted_idx] * 100,\n",
    "        name=\"Min-Variance Returns\",\n",
    "        marker_color=\"#3F51B5\",\n",
    "        opacity=0.7,\n",
    "    ),\n",
    "    row=1,\n",
    "    col=2,\n",
    ")\n",
    "\n",
    "# Add VaR threshold line.\n",
    "fig.add_hline(\n",
    "    y=-cvar_metrics[\"var_95\"] * 100,\n",
    "    line_dash=\"dash\",\n",
    "    line_color=\"#E91E63\",\n",
    "    annotation_text=\"CVaR VaR threshold\",\n",
    "    row=1,\n",
    "    col=2,\n",
    ")\n",
    "\n",
    "fig.update_xaxes(title_text=\"Asset\", row=1, col=1)\n",
    "fig.update_yaxes(title_text=\"Weight (%)\", row=1, col=1)\n",
    "fig.update_xaxes(title_text=\"Scenario (sorted by return)\", row=1, col=2)\n",
    "fig.update_yaxes(title_text=\"Monthly Return (%)\", row=1, col=2)\n",
    "\n",
    "fig.update_layout(\n",
    "    barmode=\"group\",\n",
    "    height=400,\n",
    "    margin=dict(t=40, b=40, l=60, r=40),\n",
    "    legend=dict(orientation=\"h\", yanchor=\"bottom\", y=-0.25, xanchor=\"center\", x=0.5),\n",
    ")\n",
    "HTML(fig.to_html(full_html=False, include_plotlyjs=\"cdn\"))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-16",
   "metadata": {},
   "source": "## Key observations\n\nThe CVaR-optimal portfolio differs from the minimum-variance portfolio:\n\n1. Different risk focus: CVaR optimization targets tail risk,\n   while minimum-variance treats all deviations equally.\n\n2. Asset allocation: CVaR may allocate more to assets that have better\n   worst-case behavior, even if they have higher overall variance.\n\n3. Scenario-based: CVaR uses historical scenarios directly, making no\n   normality assumptions about returns.\n\nFor risk-averse investors concerned about extreme losses (e.g., pension funds,\ninsurance companies), CVaR optimization provides a more relevant risk measure\nthan variance.\n\nFor more details on constrained optimization in jaxls, see {class}`jaxls.Cost`\nand {class}`jaxls.LeastSquaresProblem`."
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "name": "python",
   "version": "3.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
