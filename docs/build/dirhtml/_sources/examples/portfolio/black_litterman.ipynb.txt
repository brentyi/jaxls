{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "cell-0",
   "metadata": {},
   "source": [
    "# Black-Litterman Allocation\n",
    "\n",
    "The [Black-Litterman model](https://en.wikipedia.org/wiki/Black%E2%80%93Litterman_model) combines\n",
    "market equilibrium with investor views to produce optimal portfolio allocations.\n",
    "\n",
    "This approach addresses a key limitation of mean-variance optimization: sensitivity to expected\n",
    "return estimates. By starting from market-implied returns (the \"prior\") and blending in investor\n",
    "views (the \"likelihood\"), we get more stable and intuitive allocations.\n",
    "\n",
    "Features used:\n",
    "- {class}`~jaxls.Var` with vector-valued default\n",
    "- Equality constraints (`constraint_eq_zero`): budget constraint\n",
    "- Inequality constraints (`constraint_geq_zero`): no short-selling\n",
    "- Augmented Lagrangian solver for constrained optimization\n",
    "- Comparison of prior vs posterior allocations"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "cell-1",
   "metadata": {
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "import sys\n",
    "from loguru import logger\n",
    "\n",
    "logger.remove()\n",
    "logger.add(sys.stdout, format=\"<level>{level: <8}</level> | {message}\");"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "cell-2",
   "metadata": {},
   "outputs": [],
   "source": [
    "import jax\n",
    "import jax.numpy as jnp\n",
    "import jaxls"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-3",
   "metadata": {},
   "source": [
    "## Historical stock data\n",
    "\n",
    "We use the same three stocks from the {doc}`mean_variance` example:\n",
    "IBM, Walmart (WMT), and Southern Electric (SEHI)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "cell-4",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Historical monthly returns:\n",
      "  IBM: +2.60%\n",
      "  WMT: +0.81%\n",
      "  SEHI: +7.37%\n"
     ]
    }
   ],
   "source": [
    "stock_names = [\"IBM\", \"WMT\", \"SEHI\"]\n",
    "n_assets = len(stock_names)\n",
    "\n",
    "# Monthly prices (13 months: Nov 2000 - Nov 2001)\n",
    "prices = jnp.array(\n",
    "    [\n",
    "        [93.043, 51.826, 1.063],\n",
    "        [84.585, 52.823, 0.938],\n",
    "        [111.453, 56.477, 1.0],\n",
    "        [99.525, 49.805, 0.938],\n",
    "        [95.819, 50.287, 1.438],\n",
    "        [114.708, 51.521, 1.7],\n",
    "        [111.515, 51.531, 2.54],\n",
    "        [113.211, 48.664, 2.39],\n",
    "        [104.942, 55.744, 3.12],\n",
    "        [99.827, 47.916, 2.98],\n",
    "        [91.607, 49.438, 1.9],\n",
    "        [107.937, 51.336, 1.75],\n",
    "        [115.59, 55.081, 1.8],\n",
    "    ]\n",
    ")\n",
    "\n",
    "# Compute returns and covariance.\n",
    "returns = jnp.diff(prices, axis=0) / prices[:-1]\n",
    "historical_returns = jnp.mean(returns, axis=0)\n",
    "returns_centered = returns - historical_returns\n",
    "covariance = (returns_centered.T @ returns_centered) / (returns.shape[0] - 1)\n",
    "\n",
    "print(\"Historical monthly returns:\")\n",
    "for name, r in zip(stock_names, historical_returns):\n",
    "    print(f\"  {name}: {float(r) * 100:+.2f}%\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-5",
   "metadata": {},
   "source": [
    "## Black-Litterman framework\n",
    "\n",
    "The model has three components:\n",
    "\n",
    "1. Prior (market equilibrium): Expected returns implied by current market prices,\n",
    "   assuming markets are efficient. Computed via \"reverse optimization\" from market-cap weights.\n",
    "\n",
    "2. Views (investor beliefs): Specific predictions about asset returns, which can be:\n",
    "   - Absolute: \"SEHI will return 10%\"\n",
    "   - Relative: \"SEHI will outperform IBM by 5%\"\n",
    "\n",
    "3. Posterior: Bayesian combination of prior and views, weighted by confidence.\n",
    "\n",
    "The posterior expected returns are:\n",
    "\n",
    "$$\\mu_{\\text{posterior}} = \\left[(\\tau\\Sigma)^{-1} + P^T\\Omega^{-1}P\\right]^{-1}\n",
    "\\left[(\\tau\\Sigma)^{-1}\\pi + P^T\\Omega^{-1}Q\\right]$$\n",
    "\n",
    "where:\n",
    "- $\\pi$ = prior expected returns (from market equilibrium)\n",
    "- $P$ = picking matrix (maps views to assets)\n",
    "- $Q$ = view returns vector\n",
    "- $\\Omega$ = view uncertainty matrix\n",
    "- $\\tau$ = scaling parameter (typically 0.025-0.05)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-6",
   "metadata": {},
   "source": [
    "## Step 1: Computing the prior (equilibrium returns)\n",
    "\n",
    "The prior comes from \"reverse optimization\": given market-cap weights, what expected\n",
    "returns would make those weights optimal?\n",
    "\n",
    "For simplicity, we assume equal market-cap weights. The equilibrium returns are:\n",
    "\n",
    "$$\\pi = \\delta \\cdot \\Sigma \\cdot w_{\\text{market}}$$\n",
    "\n",
    "where $\\delta$ is the risk aversion coefficient (typically 2-3)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "cell-7",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Prior (equilibrium) monthly returns:\n",
      "  IBM: +1.96%\n",
      "  WMT: +1.24%\n",
      "  SEHI: +6.24%\n"
     ]
    }
   ],
   "source": [
    "# Market-cap weights (assumed equal for simplicity)\n",
    "market_weights = jnp.ones(n_assets) / n_assets\n",
    "\n",
    "# Risk aversion coefficient.\n",
    "delta = 2.5\n",
    "\n",
    "# Prior expected returns (equilibrium implied returns)\n",
    "prior_returns = delta * covariance @ market_weights\n",
    "\n",
    "print(\"Prior (equilibrium) monthly returns:\")\n",
    "for name, r in zip(stock_names, prior_returns):\n",
    "    print(f\"  {name}: {float(r) * 100:+.2f}%\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-8",
   "metadata": {},
   "source": [
    "## Step 2: Defining investor views\n",
    "\n",
    "We specify two views:\n",
    "\n",
    "1. Relative view: \"SEHI will outperform IBM by 5% (monthly)\"\n",
    "   - This is encoded as: return(SEHI) - return(IBM) = 0.05\n",
    "\n",
    "2. Absolute view: \"WMT will return 2% (monthly)\"\n",
    "   - This is encoded as: return(WMT) = 0.02\n",
    "\n",
    "The picking matrix $P$ maps views to assets, and $Q$ contains the view values."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "cell-9",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Views:\n",
      "  1. SEHI outperforms IBM by 5% (60% confidence)\n",
      "  2. WMT returns 2% (80% confidence)\n"
     ]
    }
   ],
   "source": [
    "# View 1: SEHI outperforms IBM by 5%.\n",
    "# P row: [-1 (IBM), 0 (WMT), +1 (SEHI)]\n",
    "# View 2: WMT returns 2%.\n",
    "# P row: [0 (IBM), 1 (WMT), 0 (SEHI)]\n",
    "\n",
    "P = jnp.array(\n",
    "    [\n",
    "        [-1.0, 0.0, 1.0],  # SEHI - IBM\n",
    "        [0.0, 1.0, 0.0],  # WMT\n",
    "    ]\n",
    ")\n",
    "\n",
    "Q = jnp.array([0.05, 0.02])  # View returns\n",
    "\n",
    "# View uncertainty matrix (Omega must be symmetric positive definite)\n",
    "# Using Idzorek's method: start with tau * P @ Sigma @ P.T, then scale diagonal by confidence.\n",
    "tau = 0.05\n",
    "confidence = jnp.array([0.6, 0.8])  # View 1: 60% confident, View 2: 80% confident\n",
    "\n",
    "# Scale diagonal elements only to preserve symmetry.\n",
    "# Lower confidence = higher uncertainty = larger diagonal.\n",
    "omega_diag = tau * jnp.diag(P @ covariance @ P.T) / confidence\n",
    "omega = jnp.diag(omega_diag)\n",
    "\n",
    "print(\"Views:\")\n",
    "print(\"  1. SEHI outperforms IBM by 5% (60% confidence)\")\n",
    "print(\"  2. WMT returns 2% (80% confidence)\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-10",
   "metadata": {},
   "source": [
    "## Step 3: Computing posterior returns\n",
    "\n",
    "We combine the prior and views using the Black-Litterman formula."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "cell-11",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Posterior monthly returns (after incorporating views):\n",
      "  IBM: +2.10%\n",
      "  WMT: +1.58%\n",
      "  SEHI: +6.69%\n",
      "\n",
      "Change from prior:\n",
      "  IBM: +0.14%\n",
      "  WMT: +0.34%\n",
      "  SEHI: +0.45%\n"
     ]
    }
   ],
   "source": [
    "# Black-Litterman posterior formula.\n",
    "tau_sigma_inv = jnp.linalg.inv(tau * covariance)\n",
    "omega_inv = jnp.linalg.inv(omega)\n",
    "\n",
    "# Posterior precision (inverse covariance)\n",
    "posterior_precision = tau_sigma_inv + P.T @ omega_inv @ P\n",
    "\n",
    "# Posterior mean.\n",
    "posterior_returns = jnp.linalg.solve(\n",
    "    posterior_precision, tau_sigma_inv @ prior_returns + P.T @ omega_inv @ Q\n",
    ")\n",
    "\n",
    "print(\"Posterior monthly returns (after incorporating views):\")\n",
    "for name, r in zip(stock_names, posterior_returns):\n",
    "    print(f\"  {name}: {float(r) * 100:+.2f}%\")\n",
    "\n",
    "print(\"\\nChange from prior:\")\n",
    "for name, (prior, post) in zip(stock_names, zip(prior_returns, posterior_returns)):\n",
    "    change = (float(post) - float(prior)) * 100\n",
    "    print(f\"  {name}: {change:+.2f}%\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-12",
   "metadata": {},
   "source": [
    "## Solving\n",
    "\n",
    "Now we optimize portfolios using both prior and posterior expected returns.\n",
    "We maximize expected return while minimizing variance (mean-variance optimization)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "cell-13",
   "metadata": {},
   "outputs": [],
   "source": [
    "class WeightsVar(jaxls.Var[jax.Array], default_factory=lambda: jnp.ones(3) / 3):\n",
    "    \"\"\"Portfolio weights (3D vector).\"\"\"\n",
    "\n",
    "\n",
    "weights_var = WeightsVar(id=0)\n",
    "\n",
    "\n",
    "@jaxls.Cost.factory\n",
    "def variance_cost(\n",
    "    vals: jaxls.VarValues, var: WeightsVar, cov_chol: jax.Array\n",
    ") -> jax.Array:\n",
    "    \"\"\"Minimize portfolio variance: ||L.T @ w||^2 = w.T @ cov @ w.\"\"\"\n",
    "    return cov_chol.T @ vals[var]\n",
    "\n",
    "\n",
    "@jaxls.Cost.factory\n",
    "def return_cost(\n",
    "    vals: jaxls.VarValues, var: WeightsVar, exp_ret: jax.Array, weight: float\n",
    ") -> jax.Array:\n",
    "    \"\"\"Maximize expected return (negative because we minimize).\"\"\"\n",
    "    return -weight * jnp.dot(vals[var], exp_ret)\n",
    "\n",
    "\n",
    "@jaxls.Cost.factory(kind=\"constraint_eq_zero\")\n",
    "def budget_constraint(vals: jaxls.VarValues, var: WeightsVar) -> jax.Array:\n",
    "    \"\"\"Weights must sum to 1 (fully invested).\"\"\"\n",
    "    return jnp.sum(vals[var]) - 1.0\n",
    "\n",
    "\n",
    "@jaxls.Cost.factory(kind=\"constraint_geq_zero\")\n",
    "def no_short_constraint(vals: jaxls.VarValues, var: WeightsVar) -> jax.Array:\n",
    "    \"\"\"No short-selling: weights >= 0.\"\"\"\n",
    "    return vals[var]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "cell-14",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\u001b[1mINFO    \u001b[0m | Building optimization problem with 4 terms and 1 variables: 2 costs, 1 eq_zero, 0 leq_zero, 1 geq_zero\n",
      "\u001b[1mINFO    \u001b[0m | Vectorizing constraint group with 1 constraints (constraint_geq_zero), 1 variables each: augmented_no_short_constraint\n",
      "\u001b[1mINFO    \u001b[0m | Vectorizing constraint group with 1 constraints (constraint_eq_zero), 1 variables each: augmented_budget_constraint\n",
      "\u001b[1mINFO    \u001b[0m | Vectorizing group with 1 costs, 1 variables each: return_cost\n",
      "\u001b[1mINFO    \u001b[0m | Vectorizing group with 1 costs, 1 variables each: variance_cost\n",
      "\u001b[1mINFO    \u001b[0m | Building optimization problem with 4 terms and 1 variables: 2 costs, 1 eq_zero, 0 leq_zero, 1 geq_zero\n",
      "\u001b[1mINFO    \u001b[0m | Vectorizing group with 1 costs, 1 variables each: variance_cost\n",
      "\u001b[1mINFO    \u001b[0m | Vectorizing group with 1 costs, 1 variables each: return_cost\n",
      "\u001b[1mINFO    \u001b[0m | Vectorizing constraint group with 1 constraints (constraint_geq_zero), 1 variables each: augmented_no_short_constraint\n",
      "\u001b[1mINFO    \u001b[0m | Vectorizing constraint group with 1 constraints (constraint_eq_zero), 1 variables each: augmented_budget_constraint\n",
      "Optimal weights with PRIOR returns (market equilibrium):\n",
      "  IBM: 4.7%\n",
      "  WMT: 95.3%\n",
      "  SEHI: -0.0%\n",
      "\n",
      "Optimal weights with POSTERIOR returns (after views):\n",
      "  IBM: 11.6%\n",
      "  WMT: 88.4%\n",
      "  SEHI: -0.0%\n"
     ]
    }
   ],
   "source": [
    "cov_chol = jnp.linalg.cholesky(covariance)\n",
    "return_weight = 5.0  # Trade-off between return and variance\n",
    "\n",
    "\n",
    "def optimize_portfolio(expected_returns: jax.Array) -> jax.Array:\n",
    "    \"\"\"Optimize portfolio for given expected returns.\"\"\"\n",
    "    costs = [\n",
    "        variance_cost(weights_var, cov_chol),\n",
    "        return_cost(weights_var, expected_returns, return_weight),\n",
    "        budget_constraint(weights_var),\n",
    "        no_short_constraint(weights_var),\n",
    "    ]\n",
    "    problem = jaxls.LeastSquaresProblem(costs, [weights_var]).analyze()\n",
    "    solution = problem.solve(\n",
    "        verbose=False,\n",
    "        linear_solver=\"dense_cholesky\",\n",
    "        termination=jaxls.TerminationConfig(cost_tolerance=1e-8),\n",
    "    )\n",
    "    return solution[weights_var]\n",
    "\n",
    "\n",
    "# Optimize with prior returns.\n",
    "prior_weights = optimize_portfolio(prior_returns)\n",
    "\n",
    "# Optimize with posterior returns (incorporating views)\n",
    "posterior_weights = optimize_portfolio(posterior_returns)\n",
    "\n",
    "print(\"Optimal weights with PRIOR returns (market equilibrium):\")\n",
    "for name, w in zip(stock_names, prior_weights):\n",
    "    print(f\"  {name}: {float(w) * 100:.1f}%\")\n",
    "\n",
    "print(\"\\nOptimal weights with POSTERIOR returns (after views):\")\n",
    "for name, w in zip(stock_names, posterior_weights):\n",
    "    print(f\"  {name}: {float(w) * 100:.1f}%\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-15",
   "metadata": {},
   "source": [
    "## Visualization\n",
    "\n",
    "We compare the prior vs posterior expected returns and portfolio allocations."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "cell-16",
   "metadata": {
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>                        <script type=\"text/javascript\">window.PlotlyConfig = {MathJaxConfig: 'local'};</script>\n",
       "        <script charset=\"utf-8\" src=\"https://cdn.plot.ly/plotly-3.1.0.min.js\" integrity=\"sha256-Ei4740bWZhaUTQuD6q9yQlgVCMPBz6CZWhevDYPv93A=\" crossorigin=\"anonymous\"></script>                <div id=\"a3e86317-f0ea-4380-ae36-fb78f0eb9d65\" class=\"plotly-graph-div\" style=\"height:400px; width:100%;\"></div>            <script type=\"text/javascript\">                window.PLOTLYENV=window.PLOTLYENV || {};                                if (document.getElementById(\"a3e86317-f0ea-4380-ae36-fb78f0eb9d65\")) {                    Plotly.newPlot(                        \"a3e86317-f0ea-4380-ae36-fb78f0eb9d65\",                        [{\"marker\":{\"color\":\"#2196F3\"},\"name\":\"Prior (Equilibrium)\",\"offset\":-0.175,\"width\":0.35,\"x\":[\"IBM\",\"WMT\",\"SEHI\"],\"y\":[1.9624445587396622,1.2435607612133026,6.2399812042713165],\"type\":\"bar\",\"xaxis\":\"x\",\"yaxis\":\"y\"},{\"marker\":{\"color\":\"#FF9800\"},\"name\":\"Posterior (With Views)\",\"offset\":0.175,\"width\":0.35,\"x\":[\"IBM\",\"WMT\",\"SEHI\"],\"y\":[2.099168859422207,1.5818338841199875,6.689489632844925],\"type\":\"bar\",\"xaxis\":\"x\",\"yaxis\":\"y\"},{\"marker\":{\"color\":\"#2196F3\"},\"name\":\"Prior (Equilibrium)\",\"offset\":-0.175,\"showlegend\":false,\"width\":0.35,\"x\":[\"IBM\",\"WMT\",\"SEHI\"],\"y\":[4.73109632730484,95.26890516281128,-7.358114118005687e-10],\"type\":\"bar\",\"xaxis\":\"x2\",\"yaxis\":\"y2\"},{\"marker\":{\"color\":\"#FF9800\"},\"name\":\"Posterior (With Views)\",\"offset\":0.175,\"showlegend\":false,\"width\":0.35,\"x\":[\"IBM\",\"WMT\",\"SEHI\"],\"y\":[11.596682667732239,88.4033203125,-1.2447948921634477e-9],\"type\":\"bar\",\"xaxis\":\"x2\",\"yaxis\":\"y2\"}],                        {\"template\":{\"data\":{\"histogram2dcontour\":[{\"type\":\"histogram2dcontour\",\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"},\"colorscale\":[[0.0,\"#0d0887\"],[0.1111111111111111,\"#46039f\"],[0.2222222222222222,\"#7201a8\"],[0.3333333333333333,\"#9c179e\"],[0.4444444444444444,\"#bd3786\"],[0.5555555555555556,\"#d8576b\"],[0.6666666666666666,\"#ed7953\"],[0.7777777777777778,\"#fb9f3a\"],[0.8888888888888888,\"#fdca26\"],[1.0,\"#f0f921\"]]}],\"choropleth\":[{\"type\":\"choropleth\",\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}],\"histogram2d\":[{\"type\":\"histogram2d\",\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"},\"colorscale\":[[0.0,\"#0d0887\"],[0.1111111111111111,\"#46039f\"],[0.2222222222222222,\"#7201a8\"],[0.3333333333333333,\"#9c179e\"],[0.4444444444444444,\"#bd3786\"],[0.5555555555555556,\"#d8576b\"],[0.6666666666666666,\"#ed7953\"],[0.7777777777777778,\"#fb9f3a\"],[0.8888888888888888,\"#fdca26\"],[1.0,\"#f0f921\"]]}],\"heatmap\":[{\"type\":\"heatmap\",\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"},\"colorscale\":[[0.0,\"#0d0887\"],[0.1111111111111111,\"#46039f\"],[0.2222222222222222,\"#7201a8\"],[0.3333333333333333,\"#9c179e\"],[0.4444444444444444,\"#bd3786\"],[0.5555555555555556,\"#d8576b\"],[0.6666666666666666,\"#ed7953\"],[0.7777777777777778,\"#fb9f3a\"],[0.8888888888888888,\"#fdca26\"],[1.0,\"#f0f921\"]]}],\"contourcarpet\":[{\"type\":\"contourcarpet\",\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}],\"contour\":[{\"type\":\"contour\",\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"},\"colorscale\":[[0.0,\"#0d0887\"],[0.1111111111111111,\"#46039f\"],[0.2222222222222222,\"#7201a8\"],[0.3333333333333333,\"#9c179e\"],[0.4444444444444444,\"#bd3786\"],[0.5555555555555556,\"#d8576b\"],[0.6666666666666666,\"#ed7953\"],[0.7777777777777778,\"#fb9f3a\"],[0.8888888888888888,\"#fdca26\"],[1.0,\"#f0f921\"]]}],\"surface\":[{\"type\":\"surface\",\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"},\"colorscale\":[[0.0,\"#0d0887\"],[0.1111111111111111,\"#46039f\"],[0.2222222222222222,\"#7201a8\"],[0.3333333333333333,\"#9c179e\"],[0.4444444444444444,\"#bd3786\"],[0.5555555555555556,\"#d8576b\"],[0.6666666666666666,\"#ed7953\"],[0.7777777777777778,\"#fb9f3a\"],[0.8888888888888888,\"#fdca26\"],[1.0,\"#f0f921\"]]}],\"mesh3d\":[{\"type\":\"mesh3d\",\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}],\"scatter\":[{\"fillpattern\":{\"fillmode\":\"overlay\",\"size\":10,\"solidity\":0.2},\"type\":\"scatter\"}],\"parcoords\":[{\"type\":\"parcoords\",\"line\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"scatterpolargl\":[{\"type\":\"scatterpolargl\",\"marker\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"bar\":[{\"error_x\":{\"color\":\"#2a3f5f\"},\"error_y\":{\"color\":\"#2a3f5f\"},\"marker\":{\"line\":{\"color\":\"#E5ECF6\",\"width\":0.5},\"pattern\":{\"fillmode\":\"overlay\",\"size\":10,\"solidity\":0.2}},\"type\":\"bar\"}],\"scattergeo\":[{\"type\":\"scattergeo\",\"marker\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"scatterpolar\":[{\"type\":\"scatterpolar\",\"marker\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"histogram\":[{\"marker\":{\"pattern\":{\"fillmode\":\"overlay\",\"size\":10,\"solidity\":0.2}},\"type\":\"histogram\"}],\"scattergl\":[{\"type\":\"scattergl\",\"marker\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"scatter3d\":[{\"type\":\"scatter3d\",\"line\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}},\"marker\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"scattermap\":[{\"type\":\"scattermap\",\"marker\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"scattermapbox\":[{\"type\":\"scattermapbox\",\"marker\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"scatterternary\":[{\"type\":\"scatterternary\",\"marker\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"scattercarpet\":[{\"type\":\"scattercarpet\",\"marker\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"carpet\":[{\"aaxis\":{\"endlinecolor\":\"#2a3f5f\",\"gridcolor\":\"white\",\"linecolor\":\"white\",\"minorgridcolor\":\"white\",\"startlinecolor\":\"#2a3f5f\"},\"baxis\":{\"endlinecolor\":\"#2a3f5f\",\"gridcolor\":\"white\",\"linecolor\":\"white\",\"minorgridcolor\":\"white\",\"startlinecolor\":\"#2a3f5f\"},\"type\":\"carpet\"}],\"table\":[{\"cells\":{\"fill\":{\"color\":\"#EBF0F8\"},\"line\":{\"color\":\"white\"}},\"header\":{\"fill\":{\"color\":\"#C8D4E3\"},\"line\":{\"color\":\"white\"}},\"type\":\"table\"}],\"barpolar\":[{\"marker\":{\"line\":{\"color\":\"#E5ECF6\",\"width\":0.5},\"pattern\":{\"fillmode\":\"overlay\",\"size\":10,\"solidity\":0.2}},\"type\":\"barpolar\"}],\"pie\":[{\"automargin\":true,\"type\":\"pie\"}]},\"layout\":{\"autotypenumbers\":\"strict\",\"colorway\":[\"#636efa\",\"#EF553B\",\"#00cc96\",\"#ab63fa\",\"#FFA15A\",\"#19d3f3\",\"#FF6692\",\"#B6E880\",\"#FF97FF\",\"#FECB52\"],\"font\":{\"color\":\"#2a3f5f\"},\"hovermode\":\"closest\",\"hoverlabel\":{\"align\":\"left\"},\"paper_bgcolor\":\"white\",\"plot_bgcolor\":\"#E5ECF6\",\"polar\":{\"bgcolor\":\"#E5ECF6\",\"angularaxis\":{\"gridcolor\":\"white\",\"linecolor\":\"white\",\"ticks\":\"\"},\"radialaxis\":{\"gridcolor\":\"white\",\"linecolor\":\"white\",\"ticks\":\"\"}},\"ternary\":{\"bgcolor\":\"#E5ECF6\",\"aaxis\":{\"gridcolor\":\"white\",\"linecolor\":\"white\",\"ticks\":\"\"},\"baxis\":{\"gridcolor\":\"white\",\"linecolor\":\"white\",\"ticks\":\"\"},\"caxis\":{\"gridcolor\":\"white\",\"linecolor\":\"white\",\"ticks\":\"\"}},\"coloraxis\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}},\"colorscale\":{\"sequential\":[[0.0,\"#0d0887\"],[0.1111111111111111,\"#46039f\"],[0.2222222222222222,\"#7201a8\"],[0.3333333333333333,\"#9c179e\"],[0.4444444444444444,\"#bd3786\"],[0.5555555555555556,\"#d8576b\"],[0.6666666666666666,\"#ed7953\"],[0.7777777777777778,\"#fb9f3a\"],[0.8888888888888888,\"#fdca26\"],[1.0,\"#f0f921\"]],\"sequentialminus\":[[0.0,\"#0d0887\"],[0.1111111111111111,\"#46039f\"],[0.2222222222222222,\"#7201a8\"],[0.3333333333333333,\"#9c179e\"],[0.4444444444444444,\"#bd3786\"],[0.5555555555555556,\"#d8576b\"],[0.6666666666666666,\"#ed7953\"],[0.7777777777777778,\"#fb9f3a\"],[0.8888888888888888,\"#fdca26\"],[1.0,\"#f0f921\"]],\"diverging\":[[0,\"#8e0152\"],[0.1,\"#c51b7d\"],[0.2,\"#de77ae\"],[0.3,\"#f1b6da\"],[0.4,\"#fde0ef\"],[0.5,\"#f7f7f7\"],[0.6,\"#e6f5d0\"],[0.7,\"#b8e186\"],[0.8,\"#7fbc41\"],[0.9,\"#4d9221\"],[1,\"#276419\"]]},\"xaxis\":{\"gridcolor\":\"white\",\"linecolor\":\"white\",\"ticks\":\"\",\"title\":{\"standoff\":15},\"zerolinecolor\":\"white\",\"automargin\":true,\"zerolinewidth\":2},\"yaxis\":{\"gridcolor\":\"white\",\"linecolor\":\"white\",\"ticks\":\"\",\"title\":{\"standoff\":15},\"zerolinecolor\":\"white\",\"automargin\":true,\"zerolinewidth\":2},\"scene\":{\"xaxis\":{\"backgroundcolor\":\"#E5ECF6\",\"gridcolor\":\"white\",\"linecolor\":\"white\",\"showbackground\":true,\"ticks\":\"\",\"zerolinecolor\":\"white\",\"gridwidth\":2},\"yaxis\":{\"backgroundcolor\":\"#E5ECF6\",\"gridcolor\":\"white\",\"linecolor\":\"white\",\"showbackground\":true,\"ticks\":\"\",\"zerolinecolor\":\"white\",\"gridwidth\":2},\"zaxis\":{\"backgroundcolor\":\"#E5ECF6\",\"gridcolor\":\"white\",\"linecolor\":\"white\",\"showbackground\":true,\"ticks\":\"\",\"zerolinecolor\":\"white\",\"gridwidth\":2}},\"shapedefaults\":{\"line\":{\"color\":\"#2a3f5f\"}},\"annotationdefaults\":{\"arrowcolor\":\"#2a3f5f\",\"arrowhead\":0,\"arrowwidth\":1},\"geo\":{\"bgcolor\":\"white\",\"landcolor\":\"#E5ECF6\",\"subunitcolor\":\"white\",\"showland\":true,\"showlakes\":true,\"lakecolor\":\"white\"},\"title\":{\"x\":0.05},\"mapbox\":{\"style\":\"light\"}}},\"xaxis\":{\"anchor\":\"y\",\"domain\":[0.0,0.45]},\"yaxis\":{\"anchor\":\"x\",\"domain\":[0.0,1.0],\"title\":{\"text\":\"Return (%)\"}},\"xaxis2\":{\"anchor\":\"y2\",\"domain\":[0.55,1.0]},\"yaxis2\":{\"anchor\":\"x2\",\"domain\":[0.0,1.0],\"title\":{\"text\":\"Weight (%)\"}},\"annotations\":[{\"font\":{\"size\":16},\"showarrow\":false,\"text\":\"Expected Returns (Monthly)\",\"x\":0.225,\"xanchor\":\"center\",\"xref\":\"paper\",\"y\":1.0,\"yanchor\":\"bottom\",\"yref\":\"paper\"},{\"font\":{\"size\":16},\"showarrow\":false,\"text\":\"Portfolio Allocation\",\"x\":0.775,\"xanchor\":\"center\",\"xref\":\"paper\",\"y\":1.0,\"yanchor\":\"bottom\",\"yref\":\"paper\"}],\"margin\":{\"t\":60,\"b\":40,\"l\":60,\"r\":40},\"legend\":{\"orientation\":\"h\",\"yanchor\":\"bottom\",\"y\":1.08,\"xanchor\":\"center\",\"x\":0.5},\"height\":400,\"barmode\":\"group\"},                        {\"responsive\": true}                    )                };            </script>        </div>"
      ],
      "text/plain": [
       "<IPython.core.display.HTML object>"
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import plotly.graph_objects as go\n",
    "from plotly.subplots import make_subplots\n",
    "from IPython.display import HTML\n",
    "\n",
    "colors = {\"prior\": \"#2196F3\", \"posterior\": \"#FF9800\"}\n",
    "\n",
    "fig = make_subplots(\n",
    "    rows=1,\n",
    "    cols=2,\n",
    "    subplot_titles=(\"Expected Returns (Monthly)\", \"Portfolio Allocation\"),\n",
    ")\n",
    "\n",
    "# Left plot: Expected returns comparison.\n",
    "x_pos = list(range(n_assets))\n",
    "bar_width = 0.35\n",
    "\n",
    "fig.add_trace(\n",
    "    go.Bar(\n",
    "        x=[stock_names[i] for i in x_pos],\n",
    "        y=[float(r) * 100 for r in prior_returns],\n",
    "        name=\"Prior (Equilibrium)\",\n",
    "        marker_color=colors[\"prior\"],\n",
    "        width=bar_width,\n",
    "        offset=-bar_width / 2,\n",
    "    ),\n",
    "    row=1,\n",
    "    col=1,\n",
    ")\n",
    "\n",
    "fig.add_trace(\n",
    "    go.Bar(\n",
    "        x=[stock_names[i] for i in x_pos],\n",
    "        y=[float(r) * 100 for r in posterior_returns],\n",
    "        name=\"Posterior (With Views)\",\n",
    "        marker_color=colors[\"posterior\"],\n",
    "        width=bar_width,\n",
    "        offset=bar_width / 2,\n",
    "    ),\n",
    "    row=1,\n",
    "    col=1,\n",
    ")\n",
    "\n",
    "# Right plot: Portfolio allocation comparison.\n",
    "fig.add_trace(\n",
    "    go.Bar(\n",
    "        x=[stock_names[i] for i in x_pos],\n",
    "        y=[float(w) * 100 for w in prior_weights],\n",
    "        name=\"Prior (Equilibrium)\",\n",
    "        marker_color=colors[\"prior\"],\n",
    "        width=bar_width,\n",
    "        offset=-bar_width / 2,\n",
    "        showlegend=False,\n",
    "    ),\n",
    "    row=1,\n",
    "    col=2,\n",
    ")\n",
    "\n",
    "fig.add_trace(\n",
    "    go.Bar(\n",
    "        x=[stock_names[i] for i in x_pos],\n",
    "        y=[float(w) * 100 for w in posterior_weights],\n",
    "        name=\"Posterior (With Views)\",\n",
    "        marker_color=colors[\"posterior\"],\n",
    "        width=bar_width,\n",
    "        offset=bar_width / 2,\n",
    "        showlegend=False,\n",
    "    ),\n",
    "    row=1,\n",
    "    col=2,\n",
    ")\n",
    "\n",
    "fig.update_yaxes(title_text=\"Return (%)\", row=1, col=1)\n",
    "fig.update_yaxes(title_text=\"Weight (%)\", row=1, col=2)\n",
    "\n",
    "fig.update_layout(\n",
    "    height=400,\n",
    "    margin=dict(t=60, b=40, l=60, r=40),\n",
    "    legend=dict(\n",
    "        orientation=\"h\",\n",
    "        yanchor=\"bottom\",\n",
    "        y=1.08,\n",
    "        xanchor=\"center\",\n",
    "        x=0.5,\n",
    "    ),\n",
    "    barmode=\"group\",\n",
    ")\n",
    "\n",
    "HTML(fig.to_html(full_html=False, include_plotlyjs=\"cdn\"))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-17",
   "metadata": {},
   "source": [
    "## Interpreting the results\n",
    "\n",
    "The visualization shows how investor views shift the optimal allocation:\n",
    "\n",
    "Expected Returns:\n",
    "- Our view that \"SEHI outperforms IBM by 5%\" increases SEHI's expected return and decreases IBM's\n",
    "- Our view that \"WMT returns 2%\" adjusts WMT's return toward that target\n",
    "\n",
    "Portfolio Allocation:\n",
    "- The posterior portfolio increases allocation to SEHI (which we believe will outperform)\n",
    "- Allocation to IBM decreases (the underperformer in our relative view)\n",
    "- WMT allocation adjusts based on its updated expected return\n",
    "\n",
    "This demonstrates the power of Black-Litterman: instead of directly specifying portfolio weights,\n",
    "we express our beliefs as views, and the model translates them into a coherent allocation that\n",
    "respects both market equilibrium and our specific insights.\n",
    "\n",
    "For more details on mean-variance optimization with jaxls, see {doc}`mean_variance`.\n",
    "For the core API, see {class}`jaxls.Cost` and {class}`jaxls.LeastSquaresProblem`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "05c23b7c-1ebe-47fa-ae66-a57a3cb3edf3",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
