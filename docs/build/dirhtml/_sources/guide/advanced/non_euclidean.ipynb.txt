{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "cell-0",
   "metadata": {},
   "source": "# Non-Euclidean variables\n\nMany variables in optimization live on non-Euclidean manifolds. Common examples include:\n\n- Rotations: SO(2), SO(3), quaternions\n- Rigid transformations: SE(2), SE(3)\n- Unit vectors: points on spheres\n- Probability simplices: points that sum to 1\n- Low-rank matrices, positive-definite matrices, etc.\n\nNaive Euclidean optimization of these variables often fails because it ignores geometric constraints like unit norms or orthogonality.\n\njaxls supports manifold optimization via custom `retract_fn` and `tangent_dim` parameters when defining variables.\n\nFeatures used:\n- {class}`~jaxls.SO3Var` for SO(3) rotation variables\n- {class}`~jaxls.Var` with custom `retract_fn` and `tangent_dim` for manifold variables"
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-1",
   "metadata": {
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "import sys\n",
    "from loguru import logger\n",
    "\n",
    "logger.remove()\n",
    "logger.add(sys.stdout, format=\"<level>{level: <8}</level> | {message}\");"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-2",
   "metadata": {},
   "outputs": [],
   "source": [
    "import jax\n",
    "import jax.numpy as jnp\n",
    "import jaxlie\n",
    "import jaxls"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-3",
   "metadata": {},
   "source": "## Example: Rotation Averaging\n\nRotations in 3D form the SO(3) manifold. Naive Euclidean approaches fail because quaternions must have unit norm, but averaging quaternion components produces non-unit results that require renormalization, losing the geometric structure of the problem.\n\nLet's generate some noisy rotation measurements around a ground truth:"
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-4",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Ground truth rotation (45 degrees around a diagonal axis).\n",
    "ground_truth = jaxlie.SO3.exp(jnp.array([0.3, 0.4, 0.5]))\n",
    "\n",
    "# Generate noisy measurements by perturbing with small random rotations.\n",
    "num_measurements = 10\n",
    "noise_std = 0.1  # Radians.\n",
    "\n",
    "key = jax.random.PRNGKey(42)\n",
    "noise_tangents = jax.random.normal(key, (num_measurements, 3)) * noise_std\n",
    "\n",
    "# Apply noise: measurement = ground_truth @ exp(noise).\n",
    "measurements = jax.vmap(lambda delta: ground_truth @ jaxlie.SO3.exp(delta))(\n",
    "    noise_tangents\n",
    ")\n",
    "\n",
    "# Simulate antipodal ambiguity: negate half of the quaternions.\n",
    "# (q and -q represent the same rotation, but naive averaging doesn't know this)\n",
    "# When half are negated, they nearly cancel out!\n",
    "flip_mask = jnp.arange(num_measurements) < num_measurements // 2\n",
    "flipped_wxyz = jnp.where(flip_mask[:, None], -measurements.wxyz, measurements.wxyz)\n",
    "measurements_flipped = jaxlie.SO3(wxyz=flipped_wxyz)\n",
    "\n",
    "print(f\"Ground truth quaternion: {ground_truth.wxyz}\")\n",
    "print(f\"Generated {num_measurements} noisy measurements\")\n",
    "print(f\"Negated {int(flip_mask.sum())} quaternions to simulate antipodal ambiguity\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-5",
   "metadata": {},
   "source": "### Naive Euclidean averaging (fails)\n\nA common mistake is to average quaternion components directly:"
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-6",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Average the quaternion components (wrong!).\n",
    "# This fails badly when quaternions have mixed signs due to antipodal ambiguity.\n",
    "avg_quaternion = jnp.mean(measurements_flipped.wxyz, axis=0)\n",
    "\n",
    "print(f\"Averaged quaternion: {avg_quaternion}\")\n",
    "print(f\"Quaternion norm: {jnp.linalg.norm(avg_quaternion):.4f} (should be 1.0)\")\n",
    "\n",
    "# Even if we renormalize, this approach is geometrically incorrect.\n",
    "renormalized = avg_quaternion / (jnp.linalg.norm(avg_quaternion) + 1e-8)\n",
    "naive_result = jaxlie.SO3(wxyz=renormalized)\n",
    "\n",
    "# Compute geodesic error (rotation angle between result and ground truth).\n",
    "naive_error = jnp.linalg.norm((naive_result.inverse() @ ground_truth).log())\n",
    "print(\n",
    "    f\"\\nNaive approach geodesic error: {float(naive_error):.4f} rad ({float(jnp.rad2deg(naive_error)):.2f} deg)\"\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-7",
   "metadata": {},
   "source": "## Manifold optimization\n\nThe standard approach is to optimize on the manifold using:\n\n1. **Tangent space**: At each point on the manifold, there's a local linear approximation (the tangent space). For SO(3), tangent spaces are 3-dimensional; we can parameterize local updates using axis-angle vectors.\n\n2. **Retraction**: A function that maps from the tangent space back to the manifold. For SO(3), we use the exponential map: $R_{\\text{new}} = R_{\\text{current}} \\cdot \\exp(\\delta)$, where $\\delta \\in \\mathbb{R}^3$ is an axis-angle perturbation.\n\nThe solver optimizes in the tangent space (which is Euclidean), then uses retraction to update the manifold variable."
  },
  {
   "cell_type": "markdown",
   "id": "cell-8",
   "metadata": {},
   "source": "## Using SO3Var\n\njaxls provides built-in Lie group variables through [jaxlie](https://github.com/brentyi/jaxlie). The {class}`~jaxls.SO3Var` class handles manifold optimization automatically:"
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-9",
   "metadata": {},
   "outputs": [],
   "source": [
    "# SO3Var is defined as:\n",
    "# class SO3Var(.\n",
    "#     Var[jaxlie.SO3],.\n",
    "#     default_factory=jaxlie.SO3.identity,.\n",
    "#     retract_fn=jaxlie.manifold.rplus,  # R_new = R_old @ exp(delta).\n",
    "#     tangent_dim=3,  # SO(3) has 3 degrees of freedom.\n",
    "# ): ...\n",
    "\n",
    "rotation_var = jaxls.SO3Var(id=0)\n",
    "\n",
    "print(f\"SO3Var tangent dimension: {jaxls.SO3Var.tangent_dim}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-10",
   "metadata": {},
   "source": "## Rotation averaging cost\n\nFor rotation averaging, we minimize the sum of squared geodesic distances to each measurement. The geodesic distance on SO(3) is the angle of rotation between two orientations:\n\n$$d(R, R_i) = \\|\\log(R^{-1} R_i)\\|$$\n\nThe log map returns a 3D axis-angle vector whose norm is the rotation angle."
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-11",
   "metadata": {},
   "outputs": [],
   "source": [
    "@jaxls.Cost.factory\n",
    "def rotation_cost(\n",
    "    vals: jaxls.VarValues,\n",
    "    var: jaxls.SO3Var,\n",
    "    measurement: jaxlie.SO3,\n",
    ") -> jax.Array:\n",
    "    \"\"\"Penalize deviation from measurement using geodesic distance.\n",
    "\n",
    "    Args:\n",
    "        vals: Current variable values.\n",
    "        var: The rotation variable to optimize.\n",
    "        measurement: Target rotation measurement.\n",
    "\n",
    "    Returns:\n",
    "        3D residual vector (axis-angle difference).\n",
    "    \"\"\"\n",
    "    R = vals[var]\n",
    "    # Geodesic error: log(R^{-1} @ measurement).\n",
    "    return (R.inverse() @ measurement).log()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-12",
   "metadata": {},
   "source": "## Solving with manifold optimization\n\nCreate costs for each measurement and solve:"
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-13",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Create batched costs for all measurements.\n",
    "# Note: we use the original measurements (with consistent quaternion signs).\n",
    "# The manifold approach works correctly regardless of quaternion sign.\n",
    "costs = [\n",
    "    rotation_cost(\n",
    "        jaxls.SO3Var(id=jnp.zeros(num_measurements, dtype=jnp.int32)),\n",
    "        measurements,  # Original measurements work fine.\n",
    "    )\n",
    "]\n",
    "\n",
    "# Start from identity rotation.\n",
    "initial_vals = jaxls.VarValues.make([rotation_var])\n",
    "\n",
    "# Build and solve.\n",
    "problem = jaxls.LeastSquaresProblem(costs, [rotation_var]).analyze()\n",
    "solution = problem.solve(initial_vals)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-14",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Extract result and compute error.\n",
    "manifold_result = solution[rotation_var]\n",
    "manifold_error = jnp.linalg.norm((manifold_result.inverse() @ ground_truth).log())\n",
    "\n",
    "print(f\"Ground truth quaternion:  {ground_truth.wxyz}\")\n",
    "print(f\"Manifold result quaternion: {manifold_result.wxyz}\")\n",
    "print(\n",
    "    f\"\\nManifold approach geodesic error: {float(manifold_error):.4f} rad ({float(jnp.rad2deg(manifold_error)):.2f} deg)\"\n",
    ")\n",
    "print(\n",
    "    f\"Naive approach geodesic error:    {float(naive_error):.4f} rad ({float(jnp.rad2deg(naive_error)):.2f} deg)\"\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-15",
   "metadata": {},
   "source": "## Defining custom manifold variables\n\nTo create your own manifold variable, subclass {class}`~jaxls.Var` with:\n\n- `default_factory`: A callable returning the default value\n- `retract_fn`: A function `(current_value, tangent_delta) -> new_value` that applies a tangent space update, where `tangent_delta` is a 1D array with shape `(tangent_dim,)`\n- `tangent_dim`: The dimension of the local tangent space\n\nHere's how SO3Var is implemented (you can define similar variables for other manifolds):"
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-16",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Custom SO(3) variable (equivalent to jaxls.SO3Var).\n",
    "class CustomSO3Var(\n",
    "    jaxls.Var[jaxlie.SO3],\n",
    "    default_factory=jaxlie.SO3.identity,\n",
    "    retract_fn=jaxlie.manifold.rplus,  # rplus(R, delta) = R @ SO3.exp(delta).\n",
    "    tangent_dim=3,\n",
    "):\n",
    "    \"\"\"Custom SO(3) rotation variable.\"\"\"\n",
    "\n",
    "\n",
    "# Example: Unit sphere manifold (S^2).\n",
    "def sphere_retract(point: jax.Array, delta: jax.Array) -> jax.Array:\n",
    "    \"\"\"Retract from tangent plane back to sphere.\n",
    "\n",
    "    Args:\n",
    "        point: Current point on unit sphere (3,).\n",
    "        delta: Tangent vector in local coordinates (2,).\n",
    "\n",
    "    Returns:\n",
    "        New point on unit sphere (3,).\n",
    "    \"\"\"\n",
    "    # Build orthonormal basis for tangent plane.\n",
    "    # Choose a vector not parallel to point.\n",
    "    aux = jnp.where(\n",
    "        jnp.abs(point[0]) < 0.9, jnp.array([1.0, 0.0, 0.0]), jnp.array([0.0, 1.0, 0.0])\n",
    "    )\n",
    "    e1 = aux - jnp.dot(aux, point) * point\n",
    "    e1 = e1 / jnp.linalg.norm(e1)\n",
    "    e2 = jnp.cross(point, e1)\n",
    "\n",
    "    # Move in tangent plane and project back to sphere.\n",
    "    new_point = point + delta[0] * e1 + delta[1] * e2\n",
    "    return new_point / jnp.linalg.norm(new_point)\n",
    "\n",
    "\n",
    "class UnitSphereVar(\n",
    "    jaxls.Var[jax.Array],\n",
    "    default_factory=lambda: jnp.array([0.0, 0.0, 1.0]),\n",
    "    retract_fn=sphere_retract,\n",
    "    tangent_dim=2,  # Sphere is 2D manifold embedded in 3D.\n",
    "):\n",
    "    \"\"\"Point on the unit sphere S^2.\"\"\"\n",
    "\n",
    "\n",
    "print(f\"CustomSO3Var tangent_dim: {CustomSO3Var.tangent_dim}\")\n",
    "print(f\"UnitSphereVar tangent_dim: {UnitSphereVar.tangent_dim}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-19",
   "metadata": {},
   "source": "## Visualization"
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-20",
   "metadata": {
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "import plotly.graph_objects as go\n",
    "from IPython.display import HTML\n",
    "\n",
    "\n",
    "def rotation_to_axes(\n",
    "    R: jaxlie.SO3, origin: jax.Array, scale: float = 0.3\n",
    ") -> tuple[jax.Array, jax.Array, jax.Array]:\n",
    "    \"\"\"Get axis endpoints for visualizing a rotation.\n",
    "\n",
    "    Args:\n",
    "        R: Rotation to visualize.\n",
    "        origin: Origin point (3,).\n",
    "        scale: Length of axes.\n",
    "\n",
    "    Returns:\n",
    "        Tuple of (x_axis, y_axis, z_axis) endpoints.\n",
    "    \"\"\"\n",
    "    matrix = R.as_matrix()\n",
    "    x_end = origin + scale * matrix[:, 0]\n",
    "    y_end = origin + scale * matrix[:, 1]\n",
    "    z_end = origin + scale * matrix[:, 2]\n",
    "    return x_end, y_end, z_end\n",
    "\n",
    "\n",
    "def add_frame_traces(\n",
    "    fig: go.Figure, R: jaxlie.SO3, origin: jax.Array, name: str, opacity: float = 1.0\n",
    ") -> None:\n",
    "    \"\"\"Add coordinate frame visualization to figure.\n",
    "\n",
    "    Args:\n",
    "        fig: Plotly figure to add traces to.\n",
    "        R: Rotation defining the frame orientation.\n",
    "        origin: Origin of the frame (3,).\n",
    "        name: Name prefix for legend.\n",
    "        opacity: Trace opacity.\n",
    "    \"\"\"\n",
    "    x_end, y_end, z_end = rotation_to_axes(R, origin)\n",
    "    colors = [\"red\", \"green\", \"blue\"]\n",
    "    ends = [x_end, y_end, z_end]\n",
    "    labels = [\"X\", \"Y\", \"Z\"]\n",
    "\n",
    "    for end, color, label in zip(ends, colors, labels):\n",
    "        fig.add_trace(\n",
    "            go.Scatter3d(\n",
    "                x=[float(origin[0]), float(end[0])],\n",
    "                y=[float(origin[1]), float(end[1])],\n",
    "                z=[float(origin[2]), float(end[2])],\n",
    "                mode=\"lines\",\n",
    "                line=dict(color=color, width=4 if opacity == 1.0 else 2),\n",
    "                opacity=opacity,\n",
    "                name=f\"{name} {label}\" if opacity == 1.0 else None,\n",
    "                showlegend=(opacity == 1.0 and label == \"X\"),\n",
    "                legendgroup=name,\n",
    "                hoverinfo=\"skip\",\n",
    "            )\n",
    "        )"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-21",
   "metadata": {
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "fig = go.Figure()\n",
    "\n",
    "# Add measurement frames (faded).\n",
    "for i in range(num_measurements):\n",
    "    R_meas = jaxlie.SO3(wxyz=measurements.wxyz[i])\n",
    "    add_frame_traces(fig, R_meas, jnp.zeros(3), f\"Meas {i}\", opacity=0.2)\n",
    "\n",
    "# Add ground truth (thick lines).\n",
    "add_frame_traces(fig, ground_truth, jnp.zeros(3), \"Ground Truth\")\n",
    "\n",
    "# Add manifold result (offset for visibility).\n",
    "offset = jnp.array([0.8, 0.0, 0.0])\n",
    "add_frame_traces(fig, manifold_result, offset, \"Manifold Result\")\n",
    "\n",
    "# Add naive result.\n",
    "offset2 = jnp.array([1.6, 0.0, 0.0])\n",
    "add_frame_traces(fig, naive_result, offset2, \"Naive Result\")\n",
    "\n",
    "# Add labels.\n",
    "fig.add_trace(\n",
    "    go.Scatter3d(\n",
    "        x=[0, 0.8, 1.6],\n",
    "        y=[0, 0, 0],\n",
    "        z=[-0.15, -0.15, -0.15],\n",
    "        mode=\"text\",\n",
    "        text=[\"Ground Truth\", \"Manifold\", \"Naive\"],\n",
    "        textposition=\"bottom center\",\n",
    "        showlegend=False,\n",
    "        hoverinfo=\"skip\",\n",
    "    )\n",
    ")\n",
    "\n",
    "fig.update_layout(\n",
    "    scene=dict(\n",
    "        aspectmode=\"data\",\n",
    "        xaxis=dict(\n",
    "            showbackground=False,\n",
    "            showgrid=False,\n",
    "            zeroline=False,\n",
    "            showticklabels=False,\n",
    "            title=\"\",\n",
    "        ),\n",
    "        yaxis=dict(\n",
    "            showbackground=False,\n",
    "            showgrid=False,\n",
    "            zeroline=False,\n",
    "            showticklabels=False,\n",
    "            title=\"\",\n",
    "        ),\n",
    "        zaxis=dict(\n",
    "            showbackground=False,\n",
    "            showgrid=False,\n",
    "            zeroline=False,\n",
    "            showticklabels=False,\n",
    "            title=\"\",\n",
    "        ),\n",
    "        camera=dict(eye=dict(x=1.5, y=1.5, z=1.0)),\n",
    "    ),\n",
    "    height=450,\n",
    "    margin=dict(t=20, b=20, l=20, r=20),\n",
    "    showlegend=False,\n",
    ")\n",
    "\n",
    "HTML(fig.to_html(full_html=False, include_plotlyjs=\"cdn\"))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-23",
   "metadata": {},
   "source": "The manifold-aware approach consistently achieves lower error. The naive quaternion averaging fails because it ignores the geometry of the manifold.\n\nKey points:\n- Define `retract_fn` to map tangent space updates back to the manifold\n- Set `tangent_dim` to the local degrees of freedom (not the ambient dimension)\n- Use geodesic costs that respect manifold geometry (e.g., the log map for Lie groups)\n\nBuilt-in Lie group variables:\n- {class}`jaxls.SO2Var`, {class}`jaxls.SO3Var` for rotations\n- {class}`jaxls.SE2Var`, {class}`jaxls.SE3Var` for rigid transformations\n\nFor custom manifolds (spheres, simplices, etc.), define your own variable class with appropriate `retract_fn` and `tangent_dim` as shown above."
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}