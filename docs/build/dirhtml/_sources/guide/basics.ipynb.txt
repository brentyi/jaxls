{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "cell-0",
   "metadata": {},
   "source": "# Basics\n\nAn introduction to nonlinear least squares optimization with jaxls.\n\nFeatures used:\n- {class}`~jaxls.Var` subclassing for custom variable types\n- {func}`@jaxls.Cost.factory <jaxls.Cost.factory>` for defining cost functions\n- {class}`~jaxls.LeastSquaresProblem` for building and solving optimization problems\n- {class}`~jaxls.VarValues` for accessing solution values"
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-1",
   "metadata": {
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "import sys\n",
    "from loguru import logger\n",
    "\n",
    "logger.remove()\n",
    "logger.add(sys.stdout, format=\"<level>{level: <8}</level> | {message}\");"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-2",
   "metadata": {},
   "outputs": [],
   "source": [
    "import jax\n",
    "import jax.numpy as jnp\n",
    "import jaxls"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-3",
   "metadata": {},
   "source": "## The problem: circle fitting\n\nGiven a set of noisy 2D points that lie approximately on a circle, we want to find the circle parameters (center and radius) that best fit the data.\n\nThis is a classic nonlinear least squares problem: we define residual vectors that measure the error for each data point, then minimize the sum of squared residual norms. In jaxls, a \"cost\" is a term in this objective; each cost computes a residual vector, and the solver minimizes $\\sum_i \\|r_i(x)\\|^2$."
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-4",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Generate noisy points on a circle.\n",
    "true_cx, true_cy, true_r = 2.0, 1.5, 3.0  # True circle parameters.\n",
    "num_points = 30\n",
    "noise_std = 0.15\n",
    "\n",
    "# Sample angles uniformly around the circle.\n",
    "key = jax.random.PRNGKey(42)\n",
    "angles = jnp.linspace(0, 2 * jnp.pi, num_points, endpoint=False)\n",
    "\n",
    "# Generate points with Gaussian noise.\n",
    "key, subkey = jax.random.split(key)\n",
    "noise = jax.random.normal(subkey, shape=(num_points, 2)) * noise_std\n",
    "\n",
    "points = (\n",
    "    jnp.stack(\n",
    "        [\n",
    "            true_cx + true_r * jnp.cos(angles),\n",
    "            true_cy + true_r * jnp.sin(angles),\n",
    "        ],\n",
    "        axis=-1,\n",
    "    )\n",
    "    + noise\n",
    ")\n",
    "\n",
    "print(f\"Generated {num_points} noisy points around circle\")\n",
    "print(f\"True parameters: center=({true_cx}, {true_cy}), radius={true_r}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-5",
   "metadata": {},
   "source": "## Defining variables\n\nVariables represent the unknowns we want to optimize. In jaxls, we define custom variable types by subclassing {class}`~jaxls.Var`.\n\nEach variable type specifies:\n- The data type it holds (any pytree, e.g., `jax.Array`, dataclasses, nested structures)\n- A `default_factory` that creates an initial value\n\njaxls also supports non-Euclidean variables for optimization on manifolds like rotations. See [Non-Euclidean variables](advanced/non_euclidean.ipynb) for details."
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-6",
   "metadata": {},
   "outputs": [],
   "source": "class CircleVar(\n    jaxls.Var[jax.Array],\n    default_factory=lambda: jnp.array([0.0, 0.0, 1.0]),\n):\n    \"\"\"Circle parameters: [cx, cy, radius].\"\"\"\n\n\n# Create a variable instance with a unique ID.\ncircle_var = CircleVar(id=0)\n\nprint(f\"Created variable: {circle_var}\")\nprint(f\"Default value: {CircleVar.default_factory()}\")"
  },
  {
   "cell_type": "markdown",
   "id": "cell-7",
   "metadata": {},
   "source": "## Defining costs\n\nCost functions define what we're optimizing. Use the {func}`@jaxls.Cost.factory <jaxls.Cost.factory>` decorator to create cost factories.\n\nA cost function:\n- Takes a {class}`~jaxls.VarValues` object as its first argument (for looking up variable values)\n- Takes additional arguments (variables and/or static data)\n- Returns a residual vector to minimize\n\nThe solver will minimize the sum of squared residuals across all costs."
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-8",
   "metadata": {},
   "outputs": [],
   "source": [
    "@jaxls.Cost.factory\n",
    "def circle_residual(\n",
    "    vals: jaxls.VarValues,\n",
    "    circle: CircleVar,\n",
    "    point: jax.Array,\n",
    ") -> jax.Array:\n",
    "    \"\"\"Residual for a point's distance to the circle.\n",
    "\n",
    "    Args:\n",
    "        vals: Container for looking up current variable values.\n",
    "        circle: The circle variable to fit.\n",
    "        point: A 2D point that should lie on the circle.\n",
    "\n",
    "    Returns:\n",
    "        2D residual vector pointing from closest circle point to the observed point.\n",
    "    \"\"\"\n",
    "    params = vals[circle]  # Look up the current circle parameters.\n",
    "    cx, cy, r = params[0], params[1], params[2]\n",
    "\n",
    "    # Vector from center to point.\n",
    "    diff = point - jnp.array([cx, cy])\n",
    "    dist_to_center = jnp.sqrt(jnp.sum(diff**2) + 1e-6)\n",
    "    direction = diff / dist_to_center\n",
    "\n",
    "    # 2D residual: error vector from closest circle point to observed point.\n",
    "    return (dist_to_center - r) * direction"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-9",
   "metadata": {},
   "source": "Note that `circle_residual` is now a factory that creates cost objects. We call it with variable instances and static data to create costs:"
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-10",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Create a cost for each observed point.\n",
    "# Note: for large problems, batched construction (passing arrays) is more efficient.\n",
    "costs = [circle_residual(circle_var, point) for point in points]\n",
    "\n",
    "print(f\"Created {len(costs)} cost objects\")\n",
    "print(f\"Example cost: {costs[0]}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-11",
   "metadata": {},
   "source": "## Building problems\n\nA {class}`~jaxls.LeastSquaresProblem` bundles costs and variables together. Call `.analyze()` to prepare the problem structure for solving:"
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-12",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Build the problem.\n",
    "problem = jaxls.LeastSquaresProblem(costs, [circle_var]).analyze()\n",
    "\n",
    "print(f\"Problem has {len(costs)} residual terms\")\n",
    "print(f\"Optimizing {circle_var} (3 parameters)\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-13",
   "metadata": {},
   "source": "## Solving\n\nCall `.solve()` to run the Levenberg-Marquardt optimizer. The solver iteratively adjusts the variables to minimize the sum of squared residuals."
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-14",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Solve the problem (uses default initial values from the variable's default_factory).\n",
    "solution = problem.solve()\n",
    "\n",
    "# Access the solution using the variable as a key.\n",
    "result = solution[circle_var]\n",
    "est_cx, est_cy, est_r = result[0], result[1], result[2]\n",
    "\n",
    "print(\n",
    "    f\"\\nEstimated: center=({float(est_cx):.3f}, {float(est_cy):.3f}), radius={float(est_r):.3f}\"\n",
    ")\n",
    "print(f\"True:      center=({true_cx:.3f}, {true_cy:.3f}), radius={true_r:.3f}\")\n",
    "print(\n",
    "    f\"\\nCenter error: {float(jnp.sqrt((est_cx - true_cx) ** 2 + (est_cy - true_cy) ** 2)):.4f}\"\n",
    ")\n",
    "print(f\"Radius error: {float(abs(est_r - true_r)):.4f}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-15",
   "metadata": {},
   "source": "## Visualization"
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-16",
   "metadata": {
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "import plotly.graph_objects as go\n",
    "from IPython.display import HTML\n",
    "\n",
    "\n",
    "def make_circle_trace(\n",
    "    cx: float, cy: float, r: float, name: str, color: str, dash: str = \"solid\"\n",
    ") -> go.Scatter:\n",
    "    \"\"\"Create a Plotly trace for a circle.\n",
    "\n",
    "    Args:\n",
    "        cx: Circle center x coordinate.\n",
    "        cy: Circle center y coordinate.\n",
    "        r: Circle radius.\n",
    "        name: Legend name.\n",
    "        color: Line color.\n",
    "        dash: Line dash style.\n",
    "\n",
    "    Returns:\n",
    "        Plotly Scatter trace for the circle.\n",
    "    \"\"\"\n",
    "    theta = jnp.linspace(0, 2 * jnp.pi, 100)\n",
    "    x = cx + r * jnp.cos(theta)\n",
    "    y = cy + r * jnp.sin(theta)\n",
    "    return go.Scatter(\n",
    "        x=x,\n",
    "        y=y,\n",
    "        mode=\"lines\",\n",
    "        name=name,\n",
    "        line=dict(color=color, width=2, dash=dash),\n",
    "    )\n",
    "\n",
    "\n",
    "fig = go.Figure()\n",
    "\n",
    "# Noisy data points.\n",
    "fig.add_trace(\n",
    "    go.Scatter(\n",
    "        x=points[:, 0],\n",
    "        y=points[:, 1],\n",
    "        mode=\"markers\",\n",
    "        name=\"Noisy points\",\n",
    "        marker=dict(size=8, color=\"steelblue\"),\n",
    "        hovertemplate=\"(%{x:.2f}, %{y:.2f})\",\n",
    "    )\n",
    ")\n",
    "\n",
    "# True circle.\n",
    "fig.add_trace(\n",
    "    make_circle_trace(true_cx, true_cy, true_r, \"True circle\", \"green\", \"dash\")\n",
    ")\n",
    "\n",
    "# Fitted circle.\n",
    "fig.add_trace(\n",
    "    make_circle_trace(\n",
    "        float(est_cx), float(est_cy), float(est_r), \"Fitted circle\", \"crimson\"\n",
    "    )\n",
    ")\n",
    "\n",
    "# Center points.\n",
    "fig.add_trace(\n",
    "    go.Scatter(\n",
    "        x=[true_cx, float(est_cx)],\n",
    "        y=[true_cy, float(est_cy)],\n",
    "        mode=\"markers\",\n",
    "        marker=dict(size=10, symbol=\"x\", color=[\"green\", \"crimson\"]),\n",
    "        name=\"Centers\",\n",
    "        showlegend=False,\n",
    "    )\n",
    ")\n",
    "\n",
    "fig.update_layout(\n",
    "    title=\"Circle Fitting with jaxls\",\n",
    "    xaxis_title=\"x\",\n",
    "    yaxis_title=\"y\",\n",
    "    xaxis=dict(scaleanchor=\"y\", scaleratio=1),\n",
    "    height=450,\n",
    "    margin=dict(t=40, b=40, l=40, r=40),\n",
    "    legend=dict(yanchor=\"top\", y=0.99, xanchor=\"left\", x=0.01),\n",
    ")\n",
    "\n",
    "HTML(fig.to_html(full_html=False, include_plotlyjs=\"cdn\"))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-17",
   "metadata": {},
   "source": "## Summary\n\nThe key steps for solving nonlinear least squares problems with jaxls:\n\n1. Define variables by subclassing {class}`~jaxls.Var` with a `default_factory`\n2. Define costs using {func}`@jaxls.Cost.factory <jaxls.Cost.factory>`, returning residual vectors\n3. Build the problem with {class}`~jaxls.LeastSquaresProblem` and call `.analyze()`\n4. Solve with `.solve()` and access results via the {class}`~jaxls.VarValues` object\n\nFor more, see:\n- {doc}`tips_and_gotchas`: Batched construction, residual dimensions, solver selection\n- {doc}`advanced/constraints`: Equality and inequality constraints\n- {doc}`advanced/non_euclidean`: Lie group variables for rotations and poses\n- {doc}`advanced/robust_costs`: Handling outliers with M-estimators"
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}