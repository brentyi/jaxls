{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "cell-0",
   "metadata": {},
   "source": "# Tips and gotchas\n\nPractical guidance for getting the most out of jaxls.\n\nFeatures used:\n- Batched construction for efficient problem setup\n- Residual vector structure for proper Hessian approximation\n- Jacobian mode selection (`jac_mode`)\n- Linear solver selection (`linear_solver`)\n- Debugging with `return_summary`"
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "import sys\n",
    "from loguru import logger\n",
    "\n",
    "logger.remove()\n",
    "logger.add(sys.stdout, format=\"<level>{level: <8}</level> | {message}\");"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-2",
   "metadata": {},
   "outputs": [],
   "source": [
    "import time\n",
    "\n",
    "import jax\n",
    "import jax.numpy as jnp\n",
    "import jaxls"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-3",
   "metadata": {},
   "source": [
    "## Model problem: circle fitting\n",
    "\n",
    "We'll use circle fitting as a running example. Given noisy 2D points, we want to find the center $(c_x, c_y)$ and radius $r$ of the best-fit circle."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-4",
   "metadata": {},
   "outputs": [],
   "source": [
    "class CircleVar(\n",
    "    jaxls.Var[jax.Array], default_factory=lambda: jnp.array([0.0, 0.0, 1.0])\n",
    "):\n",
    "    \"\"\"Circle parameters: (center_x, center_y, radius).\"\"\"\n",
    "\n",
    "\n",
    "# Generate points on a circle (no noise for cleaner demonstration).\n",
    "def generate_circle_points(\n",
    "    n_points: int,\n",
    "    true_center: tuple[float, float],\n",
    "    true_radius: float,\n",
    ") -> jax.Array:\n",
    "    \"\"\"Generate points sampled from a circle.\"\"\"\n",
    "    angles = jnp.linspace(0, 2 * jnp.pi, n_points, endpoint=False)\n",
    "    points = jnp.stack(\n",
    "        [\n",
    "            true_center[0] + true_radius * jnp.cos(angles),\n",
    "            true_center[1] + true_radius * jnp.sin(angles),\n",
    "        ],\n",
    "        axis=-1,\n",
    "    )\n",
    "    return points\n",
    "\n",
    "\n",
    "# Ground truth circle.\n",
    "TRUE_CENTER = (2.0, 3.0)\n",
    "TRUE_RADIUS = 5.0\n",
    "N_POINTS = 20\n",
    "\n",
    "points = generate_circle_points(N_POINTS, TRUE_CENTER, TRUE_RADIUS)\n",
    "print(\n",
    "    f\"Generated {N_POINTS} points on circle at {TRUE_CENTER} with radius {TRUE_RADIUS}\"\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8934s3fl5x8",
   "metadata": {
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "import plotly.graph_objects as go\n",
    "from IPython.display import HTML\n",
    "\n",
    "# Generate true circle for reference.\n",
    "theta = jnp.linspace(0, 2 * jnp.pi, 100)\n",
    "true_circle_x = TRUE_CENTER[0] + TRUE_RADIUS * jnp.cos(theta)\n",
    "true_circle_y = TRUE_CENTER[1] + TRUE_RADIUS * jnp.sin(theta)\n",
    "\n",
    "fig = go.Figure()\n",
    "\n",
    "# Data points.\n",
    "fig.add_trace(\n",
    "    go.Scatter(\n",
    "        x=points[:, 0],\n",
    "        y=points[:, 1],\n",
    "        mode=\"markers\",\n",
    "        marker=dict(size=10, color=\"#FF00FF\"),\n",
    "        name=\"Data points\",\n",
    "    )\n",
    ")\n",
    "\n",
    "# True circle.\n",
    "fig.add_trace(\n",
    "    go.Scatter(\n",
    "        x=true_circle_x,\n",
    "        y=true_circle_y,\n",
    "        mode=\"lines\",\n",
    "        line=dict(color=\"gray\", width=2, dash=\"dash\"),\n",
    "        name=f\"True circle (r={TRUE_RADIUS:.1f})\",\n",
    "    )\n",
    ")\n",
    "\n",
    "# True center.\n",
    "fig.add_trace(\n",
    "    go.Scatter(\n",
    "        x=[TRUE_CENTER[0]],\n",
    "        y=[TRUE_CENTER[1]],\n",
    "        mode=\"markers\",\n",
    "        marker=dict(size=10, color=\"gray\", symbol=\"x\"),\n",
    "        name=\"True center\",\n",
    "    )\n",
    ")\n",
    "\n",
    "fig.update_layout(\n",
    "    xaxis_title=\"x\",\n",
    "    yaxis_title=\"y\",\n",
    "    xaxis=dict(scaleanchor=\"y\", scaleratio=1),\n",
    "    height=350,\n",
    "    margin=dict(t=20, b=40, l=60, r=40),\n",
    "    legend=dict(yanchor=\"top\", y=0.99, xanchor=\"left\", x=0.01),\n",
    ")\n",
    "HTML(fig.to_html(full_html=False, include_plotlyjs=\"cdn\"))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-5",
   "metadata": {},
   "source": [
    "## Batched vs naive construction\n",
    "\n",
    "When building optimization problems, how you construct costs impacts setup time.\n",
    "\n",
    "Naive approach: Create individual cost objects in a Python loop. Simple but slow for large problems.\n",
    "\n",
    "Batched approach: Pass arrays of variable IDs and data. Creates all costs in one call, much faster."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-6",
   "metadata": {},
   "outputs": [],
   "source": [
    "@jaxls.Cost.factory\n",
    "def circle_residual(\n",
    "    vals: jaxls.VarValues,\n",
    "    circle_var: CircleVar,\n",
    "    point: jax.Array,\n",
    ") -> jax.Array:\n",
    "    \"\"\"Residual for fitting a circle to a point.\"\"\"\n",
    "    params = vals[circle_var]\n",
    "    center = params[:2]\n",
    "    r = params[2]\n",
    "    diff = point - center\n",
    "    dist = jnp.sqrt(jnp.sum(diff**2) + 1e-6)\n",
    "    direction = diff / dist\n",
    "    # 2D residual: error vector from closest circle point to actual point.\n",
    "    return (dist - r) * direction"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-7",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Naive construction: loop creating individual costs.\n",
    "start = time.time()\n",
    "costs_naive = [circle_residual(CircleVar(id=0), points[i]) for i in range(N_POINTS)]\n",
    "problem_naive = jaxls.LeastSquaresProblem(costs_naive, [CircleVar(id=0)]).analyze()\n",
    "elapsed_naive = time.time() - start\n",
    "print(f\"Naive construction: {len(costs_naive)} cost objects, {elapsed_naive:.3f}s\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-8",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Batched construction: pass arrays directly.\n",
    "start = time.time()\n",
    "# Use batched variable IDs (array of zeros = all point residuals reference the same circle variable).\n",
    "costs_batched = [\n",
    "    circle_residual(CircleVar(id=jnp.zeros(N_POINTS, dtype=jnp.int32)), points)\n",
    "]\n",
    "problem_batched = jaxls.LeastSquaresProblem(costs_batched, [CircleVar(id=0)]).analyze()\n",
    "elapsed_batched = time.time() - start\n",
    "print(\n",
    "    f\"Batched construction: {len(costs_batched)} cost object(s), {elapsed_batched:.3f}s\"\n",
    ")\n",
    "print(f\"Speedup: {elapsed_naive / elapsed_batched:.1f}x\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-9",
   "metadata": {},
   "source": "jaxls's problem analysis step ensures that both approaches produce identical results and solve times, but batched construction is faster because it avoids Python loop and vectorization analysis overhead."
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-10",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Verify both give the same solution.\n",
    "solution_naive = problem_naive.solve(verbose=False)\n",
    "jax.block_until_ready(solution_naive)\n",
    "\n",
    "solution_batched = problem_batched.solve(verbose=False)\n",
    "jax.block_until_ready(solution_batched)\n",
    "\n",
    "params_naive = solution_naive[CircleVar(id=0)]\n",
    "params_batched = solution_batched[CircleVar(id=0)]\n",
    "\n",
    "print(\n",
    "    f\"Naive solution:   center=({params_naive[0]:.3f}, {params_naive[1]:.3f}), radius={params_naive[2]:.3f}\"\n",
    ")\n",
    "print(\n",
    "    f\"Batched solution: center=({params_batched[0]:.3f}, {params_batched[1]:.3f}), radius={params_batched[2]:.3f}\"\n",
    ")\n",
    "print(f\"Max difference: {float(jnp.max(jnp.abs(params_naive - params_batched))):.2e}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-11",
   "metadata": {},
   "source": "## Residual vector dimension\n\nIn Gauss-Newton, the Hessian is approximated as $J^T J$ where $J$ is the Jacobian of residuals with respect to parameters. The rank of this approximation is limited by the number of residual dimensions. Higher-dimensional residuals produce higher-rank Jacobians and better Hessian approximations.\n\nFor circle fitting, consider two formulations:\n- 1D residual: `[dist - r]`, the signed distance error (shape `(1,)`)\n- 2D residual: `(dist - r) * direction`, the error vector pointing from circle to point (shape `(2,)`)\n\nBoth have the same cost when squared, but the 2D version has a 2\u00d73 Jacobian (rank 2) vs 1\u00d73 (rank 1)."
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-12",
   "metadata": {},
   "outputs": [],
   "source": [
    "# 1D residual: scalar distance error.\n",
    "@jaxls.Cost.factory\n",
    "def circle_residual_1d(\n",
    "    vals: jaxls.VarValues,\n",
    "    circle_var: CircleVar,\n",
    "    point: jax.Array,\n",
    ") -> jax.Array:\n",
    "    \"\"\"Returns 1D residual: signed distance to circle.\"\"\"\n",
    "    params = vals[circle_var]\n",
    "    center = params[:2]\n",
    "    r = params[2]\n",
    "    diff = point - center\n",
    "    dist = jnp.sqrt(jnp.sum(diff**2) + 1e-6)\n",
    "    return jnp.array([dist - r])  # Shape (1,).\n",
    "\n",
    "\n",
    "# 2D residual: error vector from circle to point.\n",
    "@jaxls.Cost.factory\n",
    "def circle_residual_2d(\n",
    "    vals: jaxls.VarValues,\n",
    "    circle_var: CircleVar,\n",
    "    point: jax.Array,\n",
    ") -> jax.Array:\n",
    "    \"\"\"Returns 2D residual: vector from closest circle point to actual point.\"\"\"\n",
    "    params = vals[circle_var]\n",
    "    center = params[:2]\n",
    "    r = params[2]\n",
    "    diff = point - center\n",
    "    dist = jnp.sqrt(jnp.sum(diff**2) + 1e-6)\n",
    "    direction = diff / dist\n",
    "    # Error vector: (dist - r) * direction.\n",
    "    return (dist - r) * direction  # Shape (2,)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-13",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Compare convergence.\n",
    "circle_var = CircleVar(id=0)\n",
    "initial_guess = jnp.array([0.0, 0.0, 1.0])\n",
    "batched_var = CircleVar(id=jnp.zeros(N_POINTS, dtype=jnp.int32))\n",
    "\n",
    "# 1D residual problem.\n",
    "problem_1d = jaxls.LeastSquaresProblem(\n",
    "    [circle_residual_1d(batched_var, points)], [circle_var]\n",
    ").analyze()\n",
    "\n",
    "# 2D residual problem.\n",
    "problem_2d = jaxls.LeastSquaresProblem(\n",
    "    [circle_residual_2d(batched_var, points)], [circle_var]\n",
    ").analyze()\n",
    "\n",
    "# Solve both.\n",
    "initial_vals = jaxls.VarValues.make([circle_var.with_value(initial_guess)])\n",
    "\n",
    "sol_1d, summary_1d = problem_1d.solve(initial_vals, verbose=False, return_summary=True)\n",
    "sol_2d, summary_2d = problem_2d.solve(initial_vals, verbose=False, return_summary=True)\n",
    "\n",
    "params_1d = sol_1d[circle_var]\n",
    "params_2d = sol_2d[circle_var]\n",
    "\n",
    "print(\n",
    "    f\"Initial guess: center=({initial_guess[0]:.1f}, {initial_guess[1]:.1f}), radius={initial_guess[2]:.1f}\"\n",
    ")\n",
    "print(\n",
    "    f\"Ground truth:  center=({TRUE_CENTER[0]:.1f}, {TRUE_CENTER[1]:.1f}), radius={TRUE_RADIUS:.1f}\"\n",
    ")\n",
    "print()\n",
    "print(\n",
    "    f\"1D residual: {int(summary_1d.iterations)} iterations -> center=({params_1d[0]:.3f}, {params_1d[1]:.3f}), radius={params_1d[2]:.3f}\"\n",
    ")\n",
    "print(\n",
    "    f\"2D residual: {int(summary_2d.iterations)} iterations -> center=({params_2d[0]:.3f}, {params_2d[1]:.3f}), radius={params_2d[2]:.3f}\"\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "v831pvigsq",
   "metadata": {},
   "source": [
    "This principle applies broadly. For reprojection error in bundle adjustment, return the 2D pixel error vector directly rather than computing `jnp.linalg.norm(error)`. The 2D residual provides a rank-2 Jacobian per observation, improving the Hessian approximation."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-14",
   "metadata": {},
   "source": [
    "## Jacobian mode selection\n",
    "\n",
    "jaxls uses autodiff to compute Jacobians. The `jac_mode` parameter controls whether to use forward-mode or reverse-mode differentiation:\n",
    "\n",
    "- `\"auto\"` (default): Automatically chooses based on dimensions\n",
    "- `\"forward\"`: Rule of thumb: better when `residual_dim > tangent_dim`\n",
    "- `\"reverse\"`: Rule of thumb: better when `tangent_dim > residual_dim`\n",
    "\n",
    "These are rough heuristics, not strict rules. In practice, it can be worth trying both modes to see which is faster for your specific problem. The `\"auto\"` choice is usually reasonable, but manual selection may help in some cases."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-15",
   "metadata": {},
   "outputs": [],
   "source": [
    "@jaxls.Cost.factory(jac_mode=\"forward\")\n",
    "def circle_residual_forward(\n",
    "    vals: jaxls.VarValues,\n",
    "    circle_var: CircleVar,\n",
    "    point: jax.Array,\n",
    ") -> jax.Array:\n",
    "    \"\"\"Circle residual with forward-mode Jacobian.\"\"\"\n",
    "    params = vals[circle_var]\n",
    "    center = params[:2]\n",
    "    r = params[2]\n",
    "    diff = point - center\n",
    "    dist = jnp.sqrt(jnp.sum(diff**2) + 1e-6)\n",
    "    direction = diff / dist\n",
    "    return (dist - r) * direction\n",
    "\n",
    "\n",
    "@jaxls.Cost.factory(jac_mode=\"reverse\")\n",
    "def circle_residual_reverse(\n",
    "    vals: jaxls.VarValues,\n",
    "    circle_var: CircleVar,\n",
    "    point: jax.Array,\n",
    ") -> jax.Array:\n",
    "    \"\"\"Circle residual with reverse-mode Jacobian.\"\"\"\n",
    "    params = vals[circle_var]\n",
    "    center = params[:2]\n",
    "    r = params[2]\n",
    "    diff = point - center\n",
    "    dist = jnp.sqrt(jnp.sum(diff**2) + 1e-6)\n",
    "    direction = diff / dist\n",
    "    return (dist - r) * direction"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-16",
   "metadata": {},
   "outputs": [],
   "source": [
    "circle_var = CircleVar(id=0)\n",
    "batched_var = CircleVar(id=jnp.zeros(N_POINTS, dtype=jnp.int32))\n",
    "\n",
    "# Solve with each mode.\n",
    "for name, cost_fn in [\n",
    "    (\"auto\", circle_residual),\n",
    "    (\"forward\", circle_residual_forward),\n",
    "    (\"reverse\", circle_residual_reverse),\n",
    "]:\n",
    "    problem = jaxls.LeastSquaresProblem(\n",
    "        [cost_fn(batched_var, points)], [circle_var]\n",
    "    ).analyze()\n",
    "\n",
    "    # Warm up JIT.\n",
    "    _ = problem.solve(verbose=False)\n",
    "    jax.block_until_ready(_)\n",
    "\n",
    "    # Time the solve.\n",
    "    start = time.time()\n",
    "    for _ in range(10):\n",
    "        sol = problem.solve(verbose=False)\n",
    "        jax.block_until_ready(sol)\n",
    "    elapsed = (time.time() - start) / 10\n",
    "\n",
    "    params = sol[circle_var]\n",
    "    print(\n",
    "        f\"{name:8s}: {elapsed * 1000:.2f}ms, center=({params[0]:.3f}, {params[1]:.3f}), radius={params[2]:.3f}\"\n",
    "    )"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-17",
   "metadata": {},
   "source": "## Linear solver choice\n\njaxls supports multiple linear solvers for the normal equations:\n\n- `\"conjugate_gradient\"` (default): Iterative solver, scales well to large problems, runs on CPU/GPU\n- `\"dense_cholesky\"`: Direct solver using dense matrices, fast for small problems (<500 variables)\n- `\"cholmod\"`: Sparse direct solver, requires [scikit-sparse](https://github.com/scikit-sparse/scikit-sparse), excellent for medium-to-large sparse problems, runs on CPU only"
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-18",
   "metadata": {},
   "outputs": [],
   "source": [
    "circle_var = CircleVar(id=0)\n",
    "batched_var = CircleVar(id=jnp.zeros(N_POINTS, dtype=jnp.int32))\n",
    "problem = jaxls.LeastSquaresProblem(\n",
    "    [circle_residual(batched_var, points)], [circle_var]\n",
    ").analyze()\n",
    "\n",
    "for solver in [\"conjugate_gradient\", \"dense_cholesky\", \"cholmod\"]:\n",
    "    # Warm up.\n",
    "    _ = problem.solve(verbose=False, linear_solver=solver)\n",
    "    jax.block_until_ready(_)\n",
    "\n",
    "    # Time it.\n",
    "    start = time.time()\n",
    "    for _ in range(10):\n",
    "        sol = problem.solve(verbose=False, linear_solver=solver)\n",
    "        jax.block_until_ready(sol)\n",
    "    elapsed = (time.time() - start) / 10\n",
    "\n",
    "    params = sol[circle_var]\n",
    "    print(f\"{solver:22s}: {elapsed * 1000:.2f}ms\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-19",
   "metadata": {},
   "source": [
    "For small problems, `dense_cholesky` is often fastest. For larger problems with sparse structure (like bundle adjustment), `cholmod` or `conjugate_gradient` scale better."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-20",
   "metadata": {},
   "source": [
    "## Numerical stability\n",
    "\n",
    "Common numerical issues and how to avoid them:\n",
    "\n",
    "1. sqrt(x) near zero: Use `sqrt(x + epsilon)` to avoid NaN gradients.\n",
    "2. Division by near-zero: Add epsilon to denominators.\n",
    "3. Large residuals: Consider robust loss functions (Huber, etc.)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-21",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Unstable: sqrt(0) has undefined gradient.\n",
    "@jaxls.Cost.factory\n",
    "def distance_unstable(\n",
    "    vals: jaxls.VarValues,\n",
    "    circle_var: CircleVar,\n",
    "    point: jax.Array,\n",
    ") -> jax.Array:\n",
    "    \"\"\"Gradient is NaN when point == center.\"\"\"\n",
    "    params = vals[circle_var]\n",
    "    center = params[:2]\n",
    "    r = params[2]\n",
    "    diff = point - center\n",
    "    dist = jnp.sqrt(jnp.sum(diff**2))  # NaN gradient at diff=0.\n",
    "    direction = diff / dist\n",
    "    return (dist - r) * direction\n",
    "\n",
    "\n",
    "# Stable: Add small epsilon for numerical stability.\n",
    "@jaxls.Cost.factory\n",
    "def distance_stable(\n",
    "    vals: jaxls.VarValues,\n",
    "    circle_var: CircleVar,\n",
    "    point: jax.Array,\n",
    ") -> jax.Array:\n",
    "    \"\"\"Epsilon prevents NaN gradients.\"\"\"\n",
    "    params = vals[circle_var]\n",
    "    center = params[:2]\n",
    "    r = params[2]\n",
    "    diff = point - center\n",
    "    dist = jnp.sqrt(jnp.sum(diff**2) + 1e-6)  # Safe.\n",
    "    direction = diff / dist\n",
    "    return (dist - r) * direction"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-22",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Demonstrate the issue: point exactly at center.\n",
    "test_point = jnp.array([2.0, 3.0])  # Same as TRUE_CENTER.\n",
    "\n",
    "\n",
    "# Direct gradient check.\n",
    "def grad_unstable(params, point):\n",
    "    diff = point - params[:2]\n",
    "    return jnp.sqrt(jnp.sum(diff**2))\n",
    "\n",
    "\n",
    "def grad_stable(params, point):\n",
    "    diff = point - params[:2]\n",
    "    return jnp.sqrt(jnp.sum(diff**2) + 1e-6)\n",
    "\n",
    "\n",
    "params_at_center = jnp.array([2.0, 3.0, 5.0])  # Center matches point.\n",
    "\n",
    "grad_u = jax.grad(grad_unstable)(params_at_center, test_point)\n",
    "grad_s = jax.grad(grad_stable)(params_at_center, test_point)\n",
    "\n",
    "print(f\"Point at center: {test_point}\")\n",
    "print(f\"Unstable gradient: {grad_u} (contains NaN!)\")\n",
    "print(f\"Stable gradient:   {grad_s} (well-defined)\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-23",
   "metadata": {},
   "source": [
    "## Debugging with return_summary\n",
    "\n",
    "When optimization doesn't converge as expected, use `return_summary=True` to inspect the solve history."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-24",
   "metadata": {},
   "outputs": [],
   "source": [
    "circle_var = CircleVar(id=0)\n",
    "batched_var = CircleVar(id=jnp.zeros(N_POINTS, dtype=jnp.int32))\n",
    "problem = jaxls.LeastSquaresProblem(\n",
    "    [circle_residual(batched_var, points)], [circle_var]\n",
    ").analyze()\n",
    "\n",
    "# Solve with summary.\n",
    "solution, summary = problem.solve(verbose=False, return_summary=True)\n",
    "\n",
    "print(f\"Iterations: {int(summary.iterations)}\")\n",
    "print(\"\\nTermination criteria (cost_delta, grad_mag, param_delta, max_iters):\")\n",
    "print(f\"  {summary.termination_criteria}\")\n",
    "print(\"\\nTermination deltas (cost_delta, grad_mag, param_delta):\")\n",
    "print(f\"  {summary.termination_deltas}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-25",
   "metadata": {
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "# Plot cost history.\n",
    "import plotly.graph_objects as go\n",
    "from IPython.display import HTML\n",
    "\n",
    "n_iters = int(summary.iterations)\n",
    "cost_history = summary.cost_history[:n_iters]\n",
    "\n",
    "fig = go.Figure()\n",
    "fig.add_trace(\n",
    "    go.Scatter(\n",
    "        x=list(range(1, n_iters + 1)),\n",
    "        y=cost_history,\n",
    "        mode=\"lines+markers\",\n",
    "        marker=dict(size=8),\n",
    "        line=dict(width=2),\n",
    "    )\n",
    ")\n",
    "fig.update_layout(\n",
    "    title=\"Optimization Convergence\",\n",
    "    xaxis_title=\"Iteration\",\n",
    "    yaxis_title=\"Cost\",\n",
    "    height=350,\n",
    "    margin=dict(t=40, b=40, l=60, r=40),\n",
    ")\n",
    "HTML(fig.to_html(full_html=False, include_plotlyjs=\"cdn\"))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-26",
   "metadata": {},
   "source": [
    "## Visualization of fitted circle"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cell-27",
   "metadata": {
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "import plotly.graph_objects as go\n",
    "from IPython.display import HTML\n",
    "\n",
    "params = solution[circle_var]\n",
    "fitted_center = params[:2]\n",
    "fitted_radius = params[2]\n",
    "\n",
    "# Generate circles for plotting.\n",
    "theta = jnp.linspace(0, 2 * jnp.pi, 100)\n",
    "true_circle_x = TRUE_CENTER[0] + TRUE_RADIUS * jnp.cos(theta)\n",
    "true_circle_y = TRUE_CENTER[1] + TRUE_RADIUS * jnp.sin(theta)\n",
    "fitted_circle_x = fitted_center[0] + fitted_radius * jnp.cos(theta)\n",
    "fitted_circle_y = fitted_center[1] + fitted_radius * jnp.sin(theta)\n",
    "\n",
    "# Initial guess circle.\n",
    "init_center = jnp.array([0.0, 0.0])\n",
    "init_radius = 1.0\n",
    "init_circle_x = init_center[0] + init_radius * jnp.cos(theta)\n",
    "init_circle_y = init_center[1] + init_radius * jnp.sin(theta)\n",
    "\n",
    "fig = go.Figure()\n",
    "\n",
    "# Data points.\n",
    "fig.add_trace(\n",
    "    go.Scatter(\n",
    "        x=points[:, 0],\n",
    "        y=points[:, 1],\n",
    "        mode=\"markers\",\n",
    "        marker=dict(size=10, color=\"#FF00FF\"),\n",
    "        name=\"Data points\",\n",
    "    )\n",
    ")\n",
    "\n",
    "# Initial guess circle.\n",
    "fig.add_trace(\n",
    "    go.Scatter(\n",
    "        x=init_circle_x,\n",
    "        y=init_circle_y,\n",
    "        mode=\"lines\",\n",
    "        line=dict(color=\"orange\", width=2, dash=\"dot\"),\n",
    "        name=f\"Initial guess (r={init_radius:.1f})\",\n",
    "    )\n",
    ")\n",
    "\n",
    "# True circle.\n",
    "fig.add_trace(\n",
    "    go.Scatter(\n",
    "        x=true_circle_x,\n",
    "        y=true_circle_y,\n",
    "        mode=\"lines\",\n",
    "        line=dict(color=\"gray\", width=2, dash=\"dash\"),\n",
    "        name=f\"True circle (r={TRUE_RADIUS:.1f})\",\n",
    "    )\n",
    ")\n",
    "\n",
    "# Fitted circle.\n",
    "fig.add_trace(\n",
    "    go.Scatter(\n",
    "        x=fitted_circle_x,\n",
    "        y=fitted_circle_y,\n",
    "        mode=\"lines\",\n",
    "        line=dict(color=\"crimson\", width=2),\n",
    "        name=f\"Fitted circle (r={float(fitted_radius):.3f})\",\n",
    "    )\n",
    ")\n",
    "\n",
    "# Centers.\n",
    "fig.add_trace(\n",
    "    go.Scatter(\n",
    "        x=[float(init_center[0])],\n",
    "        y=[float(init_center[1])],\n",
    "        mode=\"markers\",\n",
    "        marker=dict(size=10, color=\"orange\", symbol=\"x\"),\n",
    "        name=\"Initial center\",\n",
    "    )\n",
    ")\n",
    "fig.add_trace(\n",
    "    go.Scatter(\n",
    "        x=[TRUE_CENTER[0]],\n",
    "        y=[TRUE_CENTER[1]],\n",
    "        mode=\"markers\",\n",
    "        marker=dict(size=10, color=\"gray\", symbol=\"x\"),\n",
    "        name=\"True center\",\n",
    "    )\n",
    ")\n",
    "fig.add_trace(\n",
    "    go.Scatter(\n",
    "        x=[float(fitted_center[0])],\n",
    "        y=[float(fitted_center[1])],\n",
    "        mode=\"markers\",\n",
    "        marker=dict(size=10, color=\"crimson\", symbol=\"x\"),\n",
    "        name=\"Fitted center\",\n",
    "    )\n",
    ")\n",
    "\n",
    "fig.update_layout(\n",
    "    title=\"Circle Fitting Result\",\n",
    "    xaxis_title=\"x\",\n",
    "    yaxis_title=\"y\",\n",
    "    xaxis=dict(scaleanchor=\"y\", scaleratio=1),\n",
    "    height=450,\n",
    "    margin=dict(t=40, b=40, l=60, r=40),\n",
    "    legend=dict(yanchor=\"top\", y=0.99, xanchor=\"left\", x=0.01),\n",
    ")\n",
    "HTML(fig.to_html(full_html=False, include_plotlyjs=\"cdn\"))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cell-28",
   "metadata": {},
   "source": [
    "## Summary\n",
    "\n",
    "1. Use batched construction for large problems by passing arrays instead of looping\n",
    "2. Prefer higher-dimensional residuals when possible (e.g., 2D error vectors instead of scalar distances)\n",
    "3. `jac_mode=\"auto\"` usually works well; manual selection rarely needed\n",
    "4. Choose linear solver based on problem size: `dense_cholesky` for small, `conjugate_gradient` or `cholmod` for large\n",
    "5. Add epsilon to `sqrt()` and divisions for numerical stability\n",
    "6. Use `return_summary=True` to debug convergence issues\n",
    "\n",
    "For more details, see {class}`jaxls.Cost`, {class}`jaxls.LeastSquaresProblem`, and {class}`jaxls.TerminationConfig`."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
